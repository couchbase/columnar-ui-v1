{"version":3,"file":"ipaddr.js","sources":["../node_modules/ipaddr.js/lib/ipaddr.js"],"sourcesContent":["(function (root) {\n    'use strict';\n    // A list of regular expressions that match arbitrary IPv4 addresses,\n    // for which a number of weird notations exist.\n    // Note that an address like 0010.0xa5.1.1 is considered legal.\n    const ipv4Part = '(0?\\\\d+|0x[a-f0-9]+)';\n    const ipv4Regexes = {\n        fourOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n        threeOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n        twoOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n        longValue: new RegExp(`^${ipv4Part}$`, 'i')\n    };\n\n    // Regular Expression for checking Octal numbers\n    const octalRegex = new RegExp(`^0[0-7]+$`, 'i');\n    const hexRegex = new RegExp(`^0x[a-f0-9]+$`, 'i');\n\n    const zoneIndex = '%[0-9a-z]{1,}';\n\n    // IPv6-matching regular expressions.\n    // For IPv6, the task is simpler: it is enough to match the colon-delimited\n    // hexadecimal IPv6 and a transitional variant with dotted-decimal IPv4 at\n    // the end.\n    const ipv6Part = '(?:[0-9a-f]+::?)+';\n    const ipv6Regexes = {\n        zoneIndex: new RegExp(zoneIndex, 'i'),\n        'native': new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, 'i'),\n        deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}(${zoneIndex})?)$`, 'i'),\n        transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}(${zoneIndex})?$`, 'i')\n    };\n\n    // Expand :: in an IPv6 address or address part consisting of `parts` groups.\n    function expandIPv6 (string, parts) {\n        // More than one '::' means invalid adddress\n        if (string.indexOf('::') !== string.lastIndexOf('::')) {\n            return null;\n        }\n\n        let colonCount = 0;\n        let lastColon = -1;\n        let zoneId = (string.match(ipv6Regexes.zoneIndex) || [])[0];\n        let replacement, replacementCount;\n\n        // Remove zone index and save it for later\n        if (zoneId) {\n            zoneId = zoneId.substring(1);\n            string = string.replace(/%.+$/, '');\n        }\n\n        // How many parts do we already have?\n        while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {\n            colonCount++;\n        }\n\n        // 0::0 is two parts more than ::\n        if (string.substr(0, 2) === '::') {\n            colonCount--;\n        }\n\n        if (string.substr(-2, 2) === '::') {\n            colonCount--;\n        }\n\n        // The following loop would hang if colonCount > parts\n        if (colonCount > parts) {\n            return null;\n        }\n\n        // replacement = ':' + '0:' * (parts - colonCount)\n        replacementCount = parts - colonCount;\n        replacement = ':';\n        while (replacementCount--) {\n            replacement += '0:';\n        }\n\n        // Insert the missing zeroes\n        string = string.replace('::', replacement);\n\n        // Trim any garbage which may be hanging around if :: was at the edge in\n        // the source strin\n        if (string[0] === ':') {\n            string = string.slice(1);\n        }\n\n        if (string[string.length - 1] === ':') {\n            string = string.slice(0, -1);\n        }\n\n        parts = (function () {\n            const ref = string.split(':');\n            const results = [];\n\n            for (let i = 0; i < ref.length; i++) {\n                results.push(parseInt(ref[i], 16));\n            }\n\n            return results;\n        })();\n\n        return {\n            parts: parts,\n            zoneId: zoneId\n        };\n    }\n\n    // A generic CIDR (Classless Inter-Domain Routing) RFC1518 range matcher.\n    function matchCIDR (first, second, partSize, cidrBits) {\n        if (first.length !== second.length) {\n            throw new Error('ipaddr: cannot match CIDR for objects with different lengths');\n        }\n\n        let part = 0;\n        let shift;\n\n        while (cidrBits > 0) {\n            shift = partSize - cidrBits;\n            if (shift < 0) {\n                shift = 0;\n            }\n\n            if (first[part] >> shift !== second[part] >> shift) {\n                return false;\n            }\n\n            cidrBits -= partSize;\n            part += 1;\n        }\n\n        return true;\n    }\n\n    function parseIntAuto (string) {\n        // Hexadedimal base 16 (0x#)\n        if (hexRegex.test(string)) {\n            return parseInt(string, 16);\n        }\n        // While octal representation is discouraged by ECMAScript 3\n        // and forbidden by ECMAScript 5, we silently allow it to\n        // work only if the rest of the string has numbers less than 8.\n        if (string[0] === '0' && !isNaN(parseInt(string[1], 10))) {\n        if (octalRegex.test(string)) {\n            return parseInt(string, 8);\n        }\n            throw new Error(`ipaddr: cannot parse ${string} as octal`);\n        }\n        // Always include the base 10 radix!\n        return parseInt(string, 10);\n    }\n\n    function padPart (part, length) {\n        while (part.length < length) {\n            part = `0${part}`;\n        }\n\n        return part;\n    }\n\n    const ipaddr = {};\n\n    // An IPv4 address (RFC791).\n    ipaddr.IPv4 = (function () {\n        // Constructs a new IPv4 address from an array of four octets\n        // in network order (MSB first)\n        // Verifies the input.\n        function IPv4 (octets) {\n            if (octets.length !== 4) {\n                throw new Error('ipaddr: ipv4 octet count should be 4');\n            }\n\n            let i, octet;\n\n            for (i = 0; i < octets.length; i++) {\n                octet = octets[i];\n                if (!((0 <= octet && octet <= 255))) {\n                    throw new Error('ipaddr: ipv4 octet should fit in 8 bits');\n                }\n            }\n\n            this.octets = octets;\n        }\n\n        // Special IPv4 address ranges.\n        // See also https://en.wikipedia.org/wiki/Reserved_IP_addresses\n        IPv4.prototype.SpecialRanges = {\n            unspecified: [[new IPv4([0, 0, 0, 0]), 8]],\n            broadcast: [[new IPv4([255, 255, 255, 255]), 32]],\n            // RFC3171\n            multicast: [[new IPv4([224, 0, 0, 0]), 4]],\n            // RFC3927\n            linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],\n            // RFC5735\n            loopback: [[new IPv4([127, 0, 0, 0]), 8]],\n            // RFC6598\n            carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],\n            // RFC1918\n            'private': [\n                [new IPv4([10, 0, 0, 0]), 8],\n                [new IPv4([172, 16, 0, 0]), 12],\n                [new IPv4([192, 168, 0, 0]), 16]\n            ],\n            // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700\n            reserved: [\n                [new IPv4([192, 0, 0, 0]), 24],\n                [new IPv4([192, 0, 2, 0]), 24],\n                [new IPv4([192, 88, 99, 0]), 24],\n                [new IPv4([198, 51, 100, 0]), 24],\n                [new IPv4([203, 0, 113, 0]), 24],\n                [new IPv4([240, 0, 0, 0]), 4]\n            ]\n        };\n\n        // The 'kind' method exists on both IPv4 and IPv6 classes.\n        IPv4.prototype.kind = function () {\n            return 'ipv4';\n        };\n\n        // Checks if this address matches other one within given CIDR range.\n        IPv4.prototype.match = function (other, cidrRange) {\n            let ref;\n            if (cidrRange === undefined) {\n                ref = other;\n                other = ref[0];\n                cidrRange = ref[1];\n            }\n\n            if (other.kind() !== 'ipv4') {\n                throw new Error('ipaddr: cannot match ipv4 address with non-ipv4 one');\n            }\n\n            return matchCIDR(this.octets, other.octets, 8, cidrRange);\n        };\n\n        // returns a number of leading ones in IPv4 address, making sure that\n        // the rest is a solid sequence of 0's (valid netmask)\n        // returns either the CIDR length or null if mask is not valid\n        IPv4.prototype.prefixLengthFromSubnetMask = function () {\n            let cidr = 0;\n            // non-zero encountered stop scanning for zeroes\n            let stop = false;\n            // number of zeroes in octet\n            const zerotable = {\n                0: 8,\n                128: 7,\n                192: 6,\n                224: 5,\n                240: 4,\n                248: 3,\n                252: 2,\n                254: 1,\n                255: 0\n            };\n            let i, octet, zeros;\n\n            for (i = 3; i >= 0; i -= 1) {\n                octet = this.octets[i];\n                if (octet in zerotable) {\n                    zeros = zerotable[octet];\n                    if (stop && zeros !== 0) {\n                        return null;\n                    }\n\n                    if (zeros !== 8) {\n                        stop = true;\n                    }\n\n                    cidr += zeros;\n                } else {\n                    return null;\n                }\n            }\n\n            return 32 - cidr;\n        };\n\n        // Checks if the address corresponds to one of the special ranges.\n        IPv4.prototype.range = function () {\n            return ipaddr.subnetMatch(this, this.SpecialRanges);\n        };\n\n        // Returns an array of byte-sized values in network order (MSB first)\n        IPv4.prototype.toByteArray = function () {\n            return this.octets.slice(0);\n        };\n\n        // Converts this IPv4 address to an IPv4-mapped IPv6 address.\n        IPv4.prototype.toIPv4MappedAddress = function () {\n            return ipaddr.IPv6.parse(`::ffff:${this.toString()}`);\n        };\n\n        // Symmetrical method strictly for aligning with the IPv6 methods.\n        IPv4.prototype.toNormalizedString = function () {\n            return this.toString();\n        };\n\n        // Returns the address in convenient, decimal-dotted format.\n        IPv4.prototype.toString = function () {\n            return this.octets.join('.');\n        };\n\n        return IPv4;\n    })();\n\n    // A utility function to return broadcast address given the IPv4 interface and prefix length in CIDR notation\n    ipaddr.IPv4.broadcastAddressFromCIDR = function (string) {\n\n        try {\n            const cidr = this.parseCIDR(string);\n            const ipInterfaceOctets = cidr[0].toByteArray();\n            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            const octets = [];\n            let i = 0;\n            while (i < 4) {\n                // Broadcast address is bitwise OR between ip interface and inverted mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n        }\n    };\n\n    // Checks if a given string is formatted like IPv4 address.\n    ipaddr.IPv4.isIPv4 = function (string) {\n        return this.parser(string) !== null;\n    };\n\n    // Checks if a given string is a valid IPv4 address.\n    ipaddr.IPv4.isValid = function (string) {\n        try {\n            new this(this.parser(string));\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // Checks if a given string is a full four-part IPv4 Address.\n    ipaddr.IPv4.isValidFourPartDecimal = function (string) {\n        if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){3}$/)) {\n            return true;\n        } else {\n            return false;\n        }\n    };\n\n    // A utility function to return network address given the IPv4 interface and prefix length in CIDR notation\n    ipaddr.IPv4.networkAddressFromCIDR = function (string) {\n        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;\n\n        try {\n            cidr = this.parseCIDR(string);\n            ipInterfaceOctets = cidr[0].toByteArray();\n            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            octets = [];\n            i = 0;\n            while (i < 4) {\n                // Network address is bitwise AND between ip interface and mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n        }\n    };\n\n    // Tries to parse and validate a string with IPv4 address.\n    // Throws an error if it fails.\n    ipaddr.IPv4.parse = function (string) {\n        const parts = this.parser(string);\n\n        if (parts === null) {\n            throw new Error('ipaddr: string is not formatted like an IPv4 Address');\n        }\n\n        return new this(parts);\n    };\n\n    // Parses the string as an IPv4 Address with CIDR Notation.\n    ipaddr.IPv4.parseCIDR = function (string) {\n        let match;\n\n        if ((match = string.match(/^(.+)\\/(\\d+)$/))) {\n            const maskLength = parseInt(match[2]);\n            if (maskLength >= 0 && maskLength <= 32) {\n                const parsed = [this.parse(match[1]), maskLength];\n                Object.defineProperty(parsed, 'toString', {\n                    value: function () {\n                        return this.join('/');\n                    }\n                });\n                return parsed;\n            }\n        }\n\n        throw new Error('ipaddr: string is not formatted like an IPv4 CIDR range');\n    };\n\n    // Classful variants (like a.b, where a is an octet, and b is a 24-bit\n    // value representing last three octets; this corresponds to a class C\n    // address) are omitted due to classless nature of modern Internet.\n    ipaddr.IPv4.parser = function (string) {\n        let match, part, value;\n\n        // parseInt recognizes all that octal & hexadecimal weirdness for us\n        if ((match = string.match(ipv4Regexes.fourOctet))) {\n            return (function () {\n                const ref = match.slice(1, 6);\n                const results = [];\n\n                for (let i = 0; i < ref.length; i++) {\n                    part = ref[i];\n                    results.push(parseIntAuto(part));\n                }\n\n                return results;\n            })();\n        } else if ((match = string.match(ipv4Regexes.longValue))) {\n            value = parseIntAuto(match[1]);\n            if (value > 0xffffffff || value < 0) {\n                throw new Error('ipaddr: address outside defined range');\n            }\n\n            return ((function () {\n                const results = [];\n                let shift;\n\n                for (shift = 0; shift <= 24; shift += 8) {\n                    results.push((value >> shift) & 0xff);\n                }\n\n                return results;\n            })()).reverse();\n        } else if ((match = string.match(ipv4Regexes.twoOctet))) {\n            return (function () {\n                const ref = match.slice(1, 4);\n                const results = [];\n\n                value = parseIntAuto(ref[1]);\n                if (value > 0xffffff || value < 0) {\n                    throw new Error('ipaddr: address outside defined range');\n                }\n\n                results.push(parseIntAuto(ref[0]));\n                results.push((value >> 16) & 0xff);\n                results.push((value >>  8) & 0xff);\n                results.push( value        & 0xff);\n\n                return results;\n            })();\n        } else if ((match = string.match(ipv4Regexes.threeOctet))) {\n            return (function () {\n                const ref = match.slice(1, 5);\n                const results = [];\n\n                value = parseIntAuto(ref[2]);\n                if (value > 0xffff || value < 0) {\n                    throw new Error('ipaddr: address outside defined range');\n                }\n\n                results.push(parseIntAuto(ref[0]));\n                results.push(parseIntAuto(ref[1]));\n                results.push((value >> 8) & 0xff);\n                results.push( value       & 0xff);\n\n                return results;\n            })();\n        } else {\n            return null;\n        }\n    };\n\n    // A utility function to return subnet mask in IPv4 format given the prefix length\n    ipaddr.IPv4.subnetMaskFromPrefixLength = function (prefix) {\n        prefix = parseInt(prefix);\n        if (prefix < 0 || prefix > 32) {\n            throw new Error('ipaddr: invalid IPv4 prefix length');\n        }\n\n        const octets = [0, 0, 0, 0];\n        let j = 0;\n        const filledOctetCount = Math.floor(prefix / 8);\n\n        while (j < filledOctetCount) {\n            octets[j] = 255;\n            j++;\n        }\n\n        if (filledOctetCount < 4) {\n            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);\n        }\n\n        return new this(octets);\n    };\n\n    // An IPv6 address (RFC2460)\n    ipaddr.IPv6 = (function () {\n        // Constructs an IPv6 address from an array of eight 16 - bit parts\n        // or sixteen 8 - bit parts in network order(MSB first).\n        // Throws an error if the input is invalid.\n        function IPv6 (parts, zoneId) {\n            let i, part;\n\n            if (parts.length === 16) {\n                this.parts = [];\n                for (i = 0; i <= 14; i += 2) {\n                    this.parts.push((parts[i] << 8) | parts[i + 1]);\n                }\n            } else if (parts.length === 8) {\n                this.parts = parts;\n            } else {\n                throw new Error('ipaddr: ipv6 part count should be 8 or 16');\n            }\n\n            for (i = 0; i < this.parts.length; i++) {\n                part = this.parts[i];\n                if (!((0 <= part && part <= 0xffff))) {\n                    throw new Error('ipaddr: ipv6 part should fit in 16 bits');\n                }\n            }\n\n            if (zoneId) {\n                this.zoneId = zoneId;\n            }\n        }\n\n        // Special IPv6 ranges\n        IPv6.prototype.SpecialRanges = {\n            // RFC4291, here and after\n            unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],\n            linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],\n            multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],\n            loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],\n            uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],\n            ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],\n            // RFC6145\n            rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],\n            // RFC6052\n            rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],\n            // RFC3056\n            '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],\n            // RFC6052, RFC6146\n            teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],\n            // RFC4291\n            reserved: [[new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]]\n        };\n\n        // Checks if this address is an IPv4-mapped IPv6 address.\n        IPv6.prototype.isIPv4MappedAddress = function () {\n            return this.range() === 'ipv4Mapped';\n        };\n\n        // The 'kind' method exists on both IPv4 and IPv6 classes.\n        IPv6.prototype.kind = function () {\n            return 'ipv6';\n        };\n\n        // Checks if this address matches other one within given CIDR range.\n        IPv6.prototype.match = function (other, cidrRange) {\n            let ref;\n\n            if (cidrRange === undefined) {\n                ref = other;\n                other = ref[0];\n                cidrRange = ref[1];\n            }\n\n            if (other.kind() !== 'ipv6') {\n                throw new Error('ipaddr: cannot match ipv6 address with non-ipv6 one');\n            }\n\n            return matchCIDR(this.parts, other.parts, 16, cidrRange);\n        };\n\n        // returns a number of leading ones in IPv6 address, making sure that\n        // the rest is a solid sequence of 0's (valid netmask)\n        // returns either the CIDR length or null if mask is not valid\n        IPv6.prototype.prefixLengthFromSubnetMask = function () {\n            let cidr = 0;\n            // non-zero encountered stop scanning for zeroes\n            let stop = false;\n            // number of zeroes in octet\n            const zerotable = {\n                0: 16,\n                32768: 15,\n                49152: 14,\n                57344: 13,\n                61440: 12,\n                63488: 11,\n                64512: 10,\n                65024: 9,\n                65280: 8,\n                65408: 7,\n                65472: 6,\n                65504: 5,\n                65520: 4,\n                65528: 3,\n                65532: 2,\n                65534: 1,\n                65535: 0\n            };\n            let part, zeros;\n\n            for (let i = 7; i >= 0; i -= 1) {\n                part = this.parts[i];\n                if (part in zerotable) {\n                    zeros = zerotable[part];\n                    if (stop && zeros !== 0) {\n                        return null;\n                    }\n\n                    if (zeros !== 16) {\n                        stop = true;\n                    }\n\n                    cidr += zeros;\n                } else {\n                    return null;\n                }\n            }\n\n            return 128 - cidr;\n        };\n\n\n        // Checks if the address corresponds to one of the special ranges.\n        IPv6.prototype.range = function () {\n            return ipaddr.subnetMatch(this, this.SpecialRanges);\n        };\n\n        // Returns an array of byte-sized values in network order (MSB first)\n        IPv6.prototype.toByteArray = function () {\n            let part;\n            const bytes = [];\n            const ref = this.parts;\n            for (let i = 0; i < ref.length; i++) {\n                part = ref[i];\n                bytes.push(part >> 8);\n                bytes.push(part & 0xff);\n            }\n\n            return bytes;\n        };\n\n        // Returns the address in expanded format with all zeroes included, like\n        // 2001:0db8:0008:0066:0000:0000:0000:0001\n        IPv6.prototype.toFixedLengthString = function () {\n            const addr = ((function () {\n                const results = [];\n                for (let i = 0; i < this.parts.length; i++) {\n                    results.push(padPart(this.parts[i].toString(16), 4));\n                }\n\n                return results;\n            }).call(this)).join(':');\n\n            let suffix = '';\n\n            if (this.zoneId) {\n                suffix = `%${this.zoneId}`;\n            }\n\n            return addr + suffix;\n        };\n\n        // Converts this address to IPv4 address if it is an IPv4-mapped IPv6 address.\n        // Throws an error otherwise.\n        IPv6.prototype.toIPv4Address = function () {\n            if (!this.isIPv4MappedAddress()) {\n                throw new Error('ipaddr: trying to convert a generic ipv6 address to ipv4');\n            }\n\n            const ref = this.parts.slice(-2);\n            const high = ref[0];\n            const low = ref[1];\n\n            return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);\n        };\n\n        // Returns the address in expanded format with all zeroes included, like\n        // 2001:db8:8:66:0:0:0:1\n        //\n        // Deprecated: use toFixedLengthString() instead.\n        IPv6.prototype.toNormalizedString = function () {\n            const addr = ((function () {\n                const results = [];\n\n                for (let i = 0; i < this.parts.length; i++) {\n                    results.push(this.parts[i].toString(16));\n                }\n\n                return results;\n            }).call(this)).join(':');\n\n            let suffix = '';\n\n            if (this.zoneId) {\n                suffix = `%${this.zoneId}`;\n            }\n\n            return addr + suffix;\n        };\n\n        // Returns the address in compact, human-readable format like\n        // 2001:db8:8:66::1\n        // in line with RFC 5952 (see https://tools.ietf.org/html/rfc5952#section-4)\n        IPv6.prototype.toRFC5952String = function () {\n            const regex = /((^|:)(0(:|$)){2,})/g;\n            const string = this.toNormalizedString();\n            let bestMatchIndex = 0;\n            let bestMatchLength = -1;\n            let match;\n\n            while ((match = regex.exec(string))) {\n                if (match[0].length > bestMatchLength) {\n                    bestMatchIndex = match.index;\n                    bestMatchLength = match[0].length;\n                }\n            }\n\n            if (bestMatchLength < 0) {\n                return string;\n            }\n\n            return `${string.substring(0, bestMatchIndex)}::${string.substring(bestMatchIndex + bestMatchLength)}`;\n        };\n\n        // Returns the address in compact, human-readable format like\n        // 2001:db8:8:66::1\n        //\n        // Deprecated: use toRFC5952String() instead.\n        IPv6.prototype.toString = function () {\n            // Replace the first sequence of 1 or more '0' parts with '::'\n            return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, '::');\n        };\n\n        return IPv6;\n\n    })();\n\n    // A utility function to return broadcast address given the IPv6 interface and prefix length in CIDR notation\n    ipaddr.IPv6.broadcastAddressFromCIDR = function (string) {\n        try {\n            const cidr = this.parseCIDR(string);\n            const ipInterfaceOctets = cidr[0].toByteArray();\n            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            const octets = [];\n            let i = 0;\n            while (i < 16) {\n                // Broadcast address is bitwise OR between ip interface and inverted mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);\n        }\n    };\n\n    // Checks if a given string is formatted like IPv6 address.\n    ipaddr.IPv6.isIPv6 = function (string) {\n        return this.parser(string) !== null;\n    };\n\n    // Checks to see if string is a valid IPv6 Address\n    ipaddr.IPv6.isValid = function (string) {\n\n        // Since IPv6.isValid is always called first, this shortcut\n        // provides a substantial performance gain.\n        if (typeof string === 'string' && string.indexOf(':') === -1) {\n            return false;\n        }\n\n        try {\n            const addr = this.parser(string);\n            new this(addr.parts, addr.zoneId);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // A utility function to return network address given the IPv6 interface and prefix length in CIDR notation\n    ipaddr.IPv6.networkAddressFromCIDR = function (string) {\n        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;\n\n        try {\n            cidr = this.parseCIDR(string);\n            ipInterfaceOctets = cidr[0].toByteArray();\n            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            octets = [];\n            i = 0;\n            while (i < 16) {\n                // Network address is bitwise AND between ip interface and mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);\n        }\n    };\n\n    // Tries to parse and validate a string with IPv6 address.\n    // Throws an error if it fails.\n    ipaddr.IPv6.parse = function (string) {\n        const addr = this.parser(string);\n\n        if (addr.parts === null) {\n            throw new Error('ipaddr: string is not formatted like an IPv6 Address');\n        }\n\n        return new this(addr.parts, addr.zoneId);\n    };\n\n    ipaddr.IPv6.parseCIDR = function (string) {\n        let maskLength, match, parsed;\n\n        if ((match = string.match(/^(.+)\\/(\\d+)$/))) {\n            maskLength = parseInt(match[2]);\n            if (maskLength >= 0 && maskLength <= 128) {\n                parsed = [this.parse(match[1]), maskLength];\n                Object.defineProperty(parsed, 'toString', {\n                    value: function () {\n                        return this.join('/');\n                    }\n                });\n                return parsed;\n            }\n        }\n\n        throw new Error('ipaddr: string is not formatted like an IPv6 CIDR range');\n    };\n\n    // Parse an IPv6 address.\n    ipaddr.IPv6.parser = function (string) {\n        let addr, i, match, octet, octets, zoneId;\n\n        if ((match = string.match(ipv6Regexes.deprecatedTransitional))) {\n            return this.parser(`::ffff:${match[1]}`);\n        }\n        if (ipv6Regexes.native.test(string)) {\n            return expandIPv6(string, 8);\n        }\n        if ((match = string.match(ipv6Regexes.transitional))) {\n            zoneId = match[6] || '';\n            addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);\n            if (addr.parts) {\n                octets = [\n                    parseInt(match[2]),\n                    parseInt(match[3]),\n                    parseInt(match[4]),\n                    parseInt(match[5])\n                ];\n                for (i = 0; i < octets.length; i++) {\n                    octet = octets[i];\n                    if (!((0 <= octet && octet <= 255))) {\n                        return null;\n                    }\n                }\n\n                addr.parts.push(octets[0] << 8 | octets[1]);\n                addr.parts.push(octets[2] << 8 | octets[3]);\n                return {\n                    parts: addr.parts,\n                    zoneId: addr.zoneId\n                };\n            }\n        }\n\n        return null;\n    };\n\n    // A utility function to return subnet mask in IPv6 format given the prefix length\n    ipaddr.IPv6.subnetMaskFromPrefixLength = function (prefix) {\n        prefix = parseInt(prefix);\n        if (prefix < 0 || prefix > 128) {\n            throw new Error('ipaddr: invalid IPv6 prefix length');\n        }\n\n        const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        let j = 0;\n        const filledOctetCount = Math.floor(prefix / 8);\n\n        while (j < filledOctetCount) {\n            octets[j] = 255;\n            j++;\n        }\n\n        if (filledOctetCount < 16) {\n            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);\n        }\n\n        return new this(octets);\n    };\n\n    // Try to parse an array in network order (MSB first) for IPv4 and IPv6\n    ipaddr.fromByteArray = function (bytes) {\n        const length = bytes.length;\n\n        if (length === 4) {\n            return new ipaddr.IPv4(bytes);\n        } else if (length === 16) {\n            return new ipaddr.IPv6(bytes);\n        } else {\n            throw new Error('ipaddr: the binary input is neither an IPv6 nor IPv4 address');\n        }\n    };\n\n    // Checks if the address is valid IP address\n    ipaddr.isValid = function (string) {\n        return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);\n    };\n\n\n    // Attempts to parse an IP Address, first through IPv6 then IPv4.\n    // Throws an error if it could not be parsed.\n    ipaddr.parse = function (string) {\n        if (ipaddr.IPv6.isValid(string)) {\n            return ipaddr.IPv6.parse(string);\n        } else if (ipaddr.IPv4.isValid(string)) {\n            return ipaddr.IPv4.parse(string);\n        } else {\n            throw new Error('ipaddr: the address has neither IPv6 nor IPv4 format');\n        }\n    };\n\n    // Attempt to parse CIDR notation, first through IPv6 then IPv4.\n    // Throws an error if it could not be parsed.\n    ipaddr.parseCIDR = function (string) {\n        try {\n            return ipaddr.IPv6.parseCIDR(string);\n        } catch (e) {\n            try {\n                return ipaddr.IPv4.parseCIDR(string);\n            } catch (e2) {\n                throw new Error('ipaddr: the address has neither IPv6 nor IPv4 CIDR format');\n            }\n        }\n    };\n\n    // Parse an address and return plain IPv4 address if it is an IPv4-mapped address\n    ipaddr.process = function (string) {\n        const addr = this.parse(string);\n\n        if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {\n            return addr.toIPv4Address();\n        } else {\n            return addr;\n        }\n    };\n\n    // An utility function to ease named range matching. See examples below.\n    // rangeList can contain both IPv4 and IPv6 subnet entries and will not throw errors\n    // on matching IPv4 addresses to IPv6 ranges or vice versa.\n    ipaddr.subnetMatch = function (address, rangeList, defaultName) {\n        let i, rangeName, rangeSubnets, subnet;\n\n        if (defaultName === undefined || defaultName === null) {\n            defaultName = 'unicast';\n        }\n\n        for (rangeName in rangeList) {\n            if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {\n                rangeSubnets = rangeList[rangeName];\n                // ECMA5 Array.isArray isn't available everywhere\n                if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {\n                    rangeSubnets = [rangeSubnets];\n                }\n\n                for (i = 0; i < rangeSubnets.length; i++) {\n                    subnet = rangeSubnets[i];\n                    if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {\n                        return rangeName;\n                    }\n                }\n            }\n        }\n\n        return defaultName;\n    };\n\n    // Export for both the CommonJS and browser-like environment\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = ipaddr;\n\n    } else {\n        root.ipaddr = ipaddr;\n    }\n\n}(this));\n"],"names":["root","ipv4Part","ipv4Regexes","fourOctet","RegExp","threeOctet","twoOctet","longValue","octalRegex","hexRegex","ipv6Part","ipv6Regexes","zoneIndex","native","deprecatedTransitional","transitional","expandIPv6","string","parts","indexOf","lastIndexOf","replacement","replacementCount","colonCount","lastColon","zoneId","match","substring","replace","substr","slice","length","ref","split","results","i","push","parseInt","matchCIDR","first","second","partSize","cidrBits","Error","shift","part","parseIntAuto","test","isNaN","padPart","ipaddr","IPv4","octets","octet","this","prototype","SpecialRanges","unspecified","broadcast","multicast","linkLocal","loopback","carrierGradeNat","private","reserved","kind","other","cidrRange","undefined","prefixLengthFromSubnetMask","cidr","stop","zerotable","0","128","192","224","240","248","252","254","255","zeros","range","subnetMatch","toByteArray","toIPv4MappedAddress","IPv6","parse","toString","toNormalizedString","join","broadcastAddressFromCIDR","parseCIDR","ipInterfaceOctets","subnetMaskOctets","subnetMaskFromPrefixLength","e","isIPv4","parser","isValid","isValidFourPartDecimal","networkAddressFromCIDR","maskLength","parsed","Object","defineProperty","value","reverse","prefix","j","filledOctetCount","Math","floor","pow","uniqueLocal","ipv4Mapped","rfc6145","rfc6052","6to4","teredo","isIPv4MappedAddress","32768","49152","57344","61440","63488","64512","65024","65280","65408","65472","65504","65520","65528","65532","65534","65535","bytes","toFixedLengthString","addr","call","suffix","toIPv4Address","high","low","toRFC5952String","regex","bestMatchIndex","bestMatchLength","exec","index","isIPv6","fromByteArray","e2","process","address","rangeList","defaultName","rangeName","rangeSubnets","subnet","hasOwnProperty","Array","apply","module","exports"],"mappings":"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"}