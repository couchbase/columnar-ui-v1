{"version":3,"file":"angular-messages.js","sources":["../node_modules/angular-messages/angular-messages.js","../node_modules/angular-messages/index.js"],"sourcesContent":["/**\n * @license AngularJS v1.6.9\n * (c) 2010-2018 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular) {'use strict';\n\nvar forEach;\nvar isArray;\nvar isString;\nvar jqLite;\n\n/**\n * @ngdoc module\n * @name ngMessages\n * @description\n *\n * The `ngMessages` module provides enhanced support for displaying messages within templates\n * (typically within forms or when rendering message objects that return key/value data).\n * Instead of relying on JavaScript code and/or complex ng-if statements within your form template to\n * show and hide error messages specific to the state of an input field, the `ngMessages` and\n * `ngMessage` directives are designed to handle the complexity, inheritance and priority\n * sequencing based on the order of how the messages are defined in the template.\n *\n * Currently, the ngMessages module only contains the code for the `ngMessages`, `ngMessagesInclude`\n * `ngMessage` and `ngMessageExp` directives.\n *\n * ## Usage\n * The `ngMessages` directive allows keys in a key/value collection to be associated with a child element\n * (or 'message') that will show or hide based on the truthiness of that key's value in the collection. A common use\n * case for `ngMessages` is to display error messages for inputs using the `$error` object exposed by the\n * {@link ngModel ngModel} directive.\n *\n * The child elements of the `ngMessages` directive are matched to the collection keys by a `ngMessage` or\n * `ngMessageExp` directive. The value of these attributes must match a key in the collection that is provided by\n * the `ngMessages` directive.\n *\n * Consider the following example, which illustrates a typical use case of `ngMessages`. Within the form `myForm` we\n * have a text input named `myField` which is bound to the scope variable `field` using the {@link ngModel ngModel}\n * directive.\n *\n * The `myField` field is a required input of type `email` with a maximum length of 15 characters.\n *\n * ```html\n * <form name=\"myForm\">\n *   <label>\n *     Enter text:\n *     <input type=\"email\" ng-model=\"field\" name=\"myField\" required maxlength=\"15\" />\n *   </label>\n *   <div ng-messages=\"myForm.myField.$error\" role=\"alert\">\n *     <div ng-message=\"required\">Please enter a value for this field.</div>\n *     <div ng-message=\"email\">This field must be a valid email address.</div>\n *     <div ng-message=\"maxlength\">This field can be at most 15 characters long.</div>\n *   </div>\n * </form>\n * ```\n *\n * In order to show error messages corresponding to `myField` we first create an element with an `ngMessages` attribute\n * set to the `$error` object owned by the `myField` input in our `myForm` form.\n *\n * Within this element we then create separate elements for each of the possible errors that `myField` could have.\n * The `ngMessage` attribute is used to declare which element(s) will appear for which error - for example,\n * setting `ng-message=\"required\"` specifies that this particular element should be displayed when there\n * is no value present for the required field `myField` (because the key `required` will be `true` in the object\n * `myForm.myField.$error`).\n *\n * ### Message order\n *\n * By default, `ngMessages` will only display one message for a particular key/value collection at any time. If more\n * than one message (or error) key is currently true, then which message is shown is determined by the order of messages\n * in the HTML template code (messages declared first are prioritised). This mechanism means the developer does not have\n * to prioritize messages using custom JavaScript code.\n *\n * Given the following error object for our example (which informs us that the field `myField` currently has both the\n * `required` and `email` errors):\n *\n * ```javascript\n * <!-- keep in mind that ngModel automatically sets these error flags -->\n * myField.$error = { required : true, email: true, maxlength: false };\n * ```\n * The `required` message will be displayed to the user since it appears before the `email` message in the DOM.\n * Once the user types a single character, the `required` message will disappear (since the field now has a value)\n * but the `email` message will be visible because it is still applicable.\n *\n * ### Displaying multiple messages at the same time\n *\n * While `ngMessages` will by default only display one error element at a time, the `ng-messages-multiple` attribute can\n * be applied to the `ngMessages` container element to cause it to display all applicable error messages at once:\n *\n * ```html\n * <!-- attribute-style usage -->\n * <div ng-messages=\"myForm.myField.$error\" ng-messages-multiple>...</div>\n *\n * <!-- element-style usage -->\n * <ng-messages for=\"myForm.myField.$error\" multiple>...</ng-messages>\n * ```\n *\n * ## Reusing and Overriding Messages\n * In addition to prioritization, ngMessages also allows for including messages from a remote or an inline\n * template. This allows for generic collection of messages to be reused across multiple parts of an\n * application.\n *\n * ```html\n * <script type=\"text/ng-template\" id=\"error-messages\">\n *   <div ng-message=\"required\">This field is required</div>\n *   <div ng-message=\"minlength\">This field is too short</div>\n * </script>\n *\n * <div ng-messages=\"myForm.myField.$error\" role=\"alert\">\n *   <div ng-messages-include=\"error-messages\"></div>\n * </div>\n * ```\n *\n * However, including generic messages may not be useful enough to match all input fields, therefore,\n * `ngMessages` provides the ability to override messages defined in the remote template by redefining\n * them within the directive container.\n *\n * ```html\n * <!-- a generic template of error messages known as \"my-custom-messages\" -->\n * <script type=\"text/ng-template\" id=\"my-custom-messages\">\n *   <div ng-message=\"required\">This field is required</div>\n *   <div ng-message=\"minlength\">This field is too short</div>\n * </script>\n *\n * <form name=\"myForm\">\n *   <label>\n *     Email address\n *     <input type=\"email\"\n *            id=\"email\"\n *            name=\"myEmail\"\n *            ng-model=\"email\"\n *            minlength=\"5\"\n *            required />\n *   </label>\n *   <!-- any ng-message elements that appear BEFORE the ng-messages-include will\n *        override the messages present in the ng-messages-include template -->\n *   <div ng-messages=\"myForm.myEmail.$error\" role=\"alert\">\n *     <!-- this required message has overridden the template message -->\n *     <div ng-message=\"required\">You did not enter your email address</div>\n *\n *     <!-- this is a brand new message and will appear last in the prioritization -->\n *     <div ng-message=\"email\">Your email address is invalid</div>\n *\n *     <!-- and here are the generic error messages -->\n *     <div ng-messages-include=\"my-custom-messages\"></div>\n *   </div>\n * </form>\n * ```\n *\n * In the example HTML code above the message that is set on required will override the corresponding\n * required message defined within the remote template. Therefore, with particular input fields (such\n * email addresses, date fields, autocomplete inputs, etc...), specialized error messages can be applied\n * while more generic messages can be used to handle other, more general input errors.\n *\n * ## Dynamic Messaging\n * ngMessages also supports using expressions to dynamically change key values. Using arrays and\n * repeaters to list messages is also supported. This means that the code below will be able to\n * fully adapt itself and display the appropriate message when any of the expression data changes:\n *\n * ```html\n * <form name=\"myForm\">\n *   <label>\n *     Email address\n *     <input type=\"email\"\n *            name=\"myEmail\"\n *            ng-model=\"email\"\n *            minlength=\"5\"\n *            required />\n *   </label>\n *   <div ng-messages=\"myForm.myEmail.$error\" role=\"alert\">\n *     <div ng-message=\"required\">You did not enter your email address</div>\n *     <div ng-repeat=\"errorMessage in errorMessages\">\n *       <!-- use ng-message-exp for a message whose key is given by an expression -->\n *       <div ng-message-exp=\"errorMessage.type\">{{ errorMessage.text }}</div>\n *     </div>\n *   </div>\n * </form>\n * ```\n *\n * The `errorMessage.type` expression can be a string value or it can be an array so\n * that multiple errors can be associated with a single error message:\n *\n * ```html\n *   <label>\n *     Email address\n *     <input type=\"email\"\n *            ng-model=\"data.email\"\n *            name=\"myEmail\"\n *            ng-minlength=\"5\"\n *            ng-maxlength=\"100\"\n *            required />\n *   </label>\n *   <div ng-messages=\"myForm.myEmail.$error\" role=\"alert\">\n *     <div ng-message-exp=\"'required'\">You did not enter your email address</div>\n *     <div ng-message-exp=\"['minlength', 'maxlength']\">\n *       Your email must be between 5 and 100 characters long\n *     </div>\n *   </div>\n * ```\n *\n * Feel free to use other structural directives such as ng-if and ng-switch to further control\n * what messages are active and when. Be careful, if you place ng-message on the same element\n * as these structural directives, AngularJS may not be able to determine if a message is active\n * or not. Therefore it is best to place the ng-message on a child element of the structural\n * directive.\n *\n * ```html\n * <div ng-messages=\"myForm.myEmail.$error\" role=\"alert\">\n *   <div ng-if=\"showRequiredError\">\n *     <div ng-message=\"required\">Please enter something</div>\n *   </div>\n * </div>\n * ```\n *\n * ## Animations\n * If the `ngAnimate` module is active within the application then the `ngMessages`, `ngMessage` and\n * `ngMessageExp` directives will trigger animations whenever any messages are added and removed from\n * the DOM by the `ngMessages` directive.\n *\n * Whenever the `ngMessages` directive contains one or more visible messages then the `.ng-active` CSS\n * class will be added to the element. The `.ng-inactive` CSS class will be applied when there are no\n * messages present. Therefore, CSS transitions and keyframes as well as JavaScript animations can\n * hook into the animations whenever these classes are added/removed.\n *\n * Let's say that our HTML code for our messages container looks like so:\n *\n * ```html\n * <div ng-messages=\"myMessages\" class=\"my-messages\" role=\"alert\">\n *   <div ng-message=\"alert\" class=\"some-message\">...</div>\n *   <div ng-message=\"fail\" class=\"some-message\">...</div>\n * </div>\n * ```\n *\n * Then the CSS animation code for the message container looks like so:\n *\n * ```css\n * .my-messages {\n *   transition:1s linear all;\n * }\n * .my-messages.ng-active {\n *   // messages are visible\n * }\n * .my-messages.ng-inactive {\n *   // messages are hidden\n * }\n * ```\n *\n * Whenever an inner message is attached (becomes visible) or removed (becomes hidden) then the enter\n * and leave animation is triggered for each particular element bound to the `ngMessage` directive.\n *\n * Therefore, the CSS code for the inner messages looks like so:\n *\n * ```css\n * .some-message {\n *   transition:1s linear all;\n * }\n *\n * .some-message.ng-enter {}\n * .some-message.ng-enter.ng-enter-active {}\n *\n * .some-message.ng-leave {}\n * .some-message.ng-leave.ng-leave-active {}\n * ```\n *\n * {@link ngAnimate Click here} to learn how to use JavaScript animations or to learn more about ngAnimate.\n */\nangular.module('ngMessages', [], function initAngularHelpers() {\n  // Access helpers from AngularJS core.\n  // Do it inside a `config` block to ensure `window.angular` is available.\n  forEach = angular.forEach;\n  isArray = angular.isArray;\n  isString = angular.isString;\n  jqLite = angular.element;\n})\n  .info({ angularVersion: '1.6.9' })\n\n  /**\n   * @ngdoc directive\n   * @module ngMessages\n   * @name ngMessages\n   * @restrict AE\n   *\n   * @description\n   * `ngMessages` is a directive that is designed to show and hide messages based on the state\n   * of a key/value object that it listens on. The directive itself complements error message\n   * reporting with the `ngModel` $error object (which stores a key/value state of validation errors).\n   *\n   * `ngMessages` manages the state of internal messages within its container element. The internal\n   * messages use the `ngMessage` directive and will be inserted/removed from the page depending\n   * on if they're present within the key/value object. By default, only one message will be displayed\n   * at a time and this depends on the prioritization of the messages within the template. (This can\n   * be changed by using the `ng-messages-multiple` or `multiple` attribute on the directive container.)\n   *\n   * A remote template can also be used to promote message reusability and messages can also be\n   * overridden.\n   *\n   * {@link module:ngMessages Click here} to learn more about `ngMessages` and `ngMessage`.\n   *\n   * @usage\n   * ```html\n   * <!-- using attribute directives -->\n   * <ANY ng-messages=\"expression\" role=\"alert\">\n   *   <ANY ng-message=\"stringValue\">...</ANY>\n   *   <ANY ng-message=\"stringValue1, stringValue2, ...\">...</ANY>\n   *   <ANY ng-message-exp=\"expressionValue\">...</ANY>\n   * </ANY>\n   *\n   * <!-- or by using element directives -->\n   * <ng-messages for=\"expression\" role=\"alert\">\n   *   <ng-message when=\"stringValue\">...</ng-message>\n   *   <ng-message when=\"stringValue1, stringValue2, ...\">...</ng-message>\n   *   <ng-message when-exp=\"expressionValue\">...</ng-message>\n   * </ng-messages>\n   * ```\n   *\n   * @param {string} ngMessages an AngularJS expression evaluating to a key/value object\n   *                 (this is typically the $error object on an ngModel instance).\n   * @param {string=} ngMessagesMultiple|multiple when set, all messages will be displayed with true\n   *\n   * @example\n   * <example name=\"ngMessages-directive\" module=\"ngMessagesExample\"\n   *          deps=\"angular-messages.js\"\n   *          animations=\"true\" fixBase=\"true\">\n   *   <file name=\"index.html\">\n   *     <form name=\"myForm\">\n   *       <label>\n   *         Enter your name:\n   *         <input type=\"text\"\n   *                name=\"myName\"\n   *                ng-model=\"name\"\n   *                ng-minlength=\"5\"\n   *                ng-maxlength=\"20\"\n   *                required />\n   *       </label>\n   *       <pre>myForm.myName.$error = {{ myForm.myName.$error | json }}</pre>\n   *\n   *       <div ng-messages=\"myForm.myName.$error\" style=\"color:maroon\" role=\"alert\">\n   *         <div ng-message=\"required\">You did not enter a field</div>\n   *         <div ng-message=\"minlength\">Your field is too short</div>\n   *         <div ng-message=\"maxlength\">Your field is too long</div>\n   *       </div>\n   *     </form>\n   *   </file>\n   *   <file name=\"script.js\">\n   *     angular.module('ngMessagesExample', ['ngMessages']);\n   *   </file>\n   * </example>\n   */\n  .directive('ngMessages', ['$animate', function($animate) {\n    var ACTIVE_CLASS = 'ng-active';\n    var INACTIVE_CLASS = 'ng-inactive';\n\n    return {\n      require: 'ngMessages',\n      restrict: 'AE',\n      controller: ['$element', '$scope', '$attrs', function NgMessagesCtrl($element, $scope, $attrs) {\n        var ctrl = this;\n        var latestKey = 0;\n        var nextAttachId = 0;\n\n        this.getAttachId = function getAttachId() { return nextAttachId++; };\n\n        var messages = this.messages = {};\n        var renderLater, cachedCollection;\n\n        this.render = function(collection) {\n          collection = collection || {};\n\n          renderLater = false;\n          cachedCollection = collection;\n\n          // this is true if the attribute is empty or if the attribute value is truthy\n          var multiple = isAttrTruthy($scope, $attrs.ngMessagesMultiple) ||\n                         isAttrTruthy($scope, $attrs.multiple);\n\n          var unmatchedMessages = [];\n          var matchedKeys = {};\n          var messageItem = ctrl.head;\n          var messageFound = false;\n          var totalMessages = 0;\n\n          // we use != instead of !== to allow for both undefined and null values\n          while (messageItem != null) {\n            totalMessages++;\n            var messageCtrl = messageItem.message;\n\n            var messageUsed = false;\n            if (!messageFound) {\n              forEach(collection, function(value, key) {\n                if (!messageUsed && truthy(value) && messageCtrl.test(key)) {\n                  // this is to prevent the same error name from showing up twice\n                  if (matchedKeys[key]) return;\n                  matchedKeys[key] = true;\n\n                  messageUsed = true;\n                  messageCtrl.attach();\n                }\n              });\n            }\n\n            if (messageUsed) {\n              // unless we want to display multiple messages then we should\n              // set a flag here to avoid displaying the next message in the list\n              messageFound = !multiple;\n            } else {\n              unmatchedMessages.push(messageCtrl);\n            }\n\n            messageItem = messageItem.next;\n          }\n\n          forEach(unmatchedMessages, function(messageCtrl) {\n            messageCtrl.detach();\n          });\n\n          if (unmatchedMessages.length !== totalMessages) {\n            $animate.setClass($element, ACTIVE_CLASS, INACTIVE_CLASS);\n          } else {\n            $animate.setClass($element, INACTIVE_CLASS, ACTIVE_CLASS);\n          }\n        };\n\n        $scope.$watchCollection($attrs.ngMessages || $attrs['for'], ctrl.render);\n\n        this.reRender = function() {\n          if (!renderLater) {\n            renderLater = true;\n            $scope.$evalAsync(function() {\n              if (renderLater && cachedCollection) {\n                ctrl.render(cachedCollection);\n              }\n            });\n          }\n        };\n\n        this.register = function(comment, messageCtrl) {\n          var nextKey = latestKey.toString();\n          messages[nextKey] = {\n            message: messageCtrl\n          };\n          insertMessageNode($element[0], comment, nextKey);\n          comment.$$ngMessageNode = nextKey;\n          latestKey++;\n\n          ctrl.reRender();\n        };\n\n        this.deregister = function(comment) {\n          var key = comment.$$ngMessageNode;\n          delete comment.$$ngMessageNode;\n          removeMessageNode($element[0], comment, key);\n          delete messages[key];\n          ctrl.reRender();\n        };\n\n        function findPreviousMessage(parent, comment) {\n          var prevNode = comment;\n          var parentLookup = [];\n\n          while (prevNode && prevNode !== parent) {\n            var prevKey = prevNode.$$ngMessageNode;\n            if (prevKey && prevKey.length) {\n              return messages[prevKey];\n            }\n\n            // dive deeper into the DOM and examine its children for any ngMessage\n            // comments that may be in an element that appears deeper in the list\n            if (prevNode.childNodes.length && parentLookup.indexOf(prevNode) === -1) {\n              parentLookup.push(prevNode);\n              prevNode = prevNode.childNodes[prevNode.childNodes.length - 1];\n            } else if (prevNode.previousSibling) {\n              prevNode = prevNode.previousSibling;\n            } else {\n              prevNode = prevNode.parentNode;\n              parentLookup.push(prevNode);\n            }\n          }\n        }\n\n        function insertMessageNode(parent, comment, key) {\n          var messageNode = messages[key];\n          if (!ctrl.head) {\n            ctrl.head = messageNode;\n          } else {\n            var match = findPreviousMessage(parent, comment);\n            if (match) {\n              messageNode.next = match.next;\n              match.next = messageNode;\n            } else {\n              messageNode.next = ctrl.head;\n              ctrl.head = messageNode;\n            }\n          }\n        }\n\n        function removeMessageNode(parent, comment, key) {\n          var messageNode = messages[key];\n\n          // This message node may have already been removed by a call to deregister()\n          if (!messageNode) return;\n\n          var match = findPreviousMessage(parent, comment);\n          if (match) {\n            match.next = messageNode.next;\n          } else {\n            ctrl.head = messageNode.next;\n          }\n        }\n      }]\n    };\n\n    function isAttrTruthy(scope, attr) {\n     return (isString(attr) && attr.length === 0) || //empty attribute\n            truthy(scope.$eval(attr));\n    }\n\n    function truthy(val) {\n      return isString(val) ? val.length : !!val;\n    }\n  }])\n\n  /**\n   * @ngdoc directive\n   * @name ngMessagesInclude\n   * @restrict AE\n   * @scope\n   *\n   * @description\n   * `ngMessagesInclude` is a directive with the purpose to import existing ngMessage template\n   * code from a remote template and place the downloaded template code into the exact spot\n   * that the ngMessagesInclude directive is placed within the ngMessages container. This allows\n   * for a series of pre-defined messages to be reused and also allows for the developer to\n   * determine what messages are overridden due to the placement of the ngMessagesInclude directive.\n   *\n   * @usage\n   * ```html\n   * <!-- using attribute directives -->\n   * <ANY ng-messages=\"expression\" role=\"alert\">\n   *   <ANY ng-messages-include=\"remoteTplString\">...</ANY>\n   * </ANY>\n   *\n   * <!-- or by using element directives -->\n   * <ng-messages for=\"expression\" role=\"alert\">\n   *   <ng-messages-include src=\"expressionValue1\">...</ng-messages-include>\n   * </ng-messages>\n   * ```\n   *\n   * {@link module:ngMessages Click here} to learn more about `ngMessages` and `ngMessage`.\n   *\n   * @param {string} ngMessagesInclude|src a string value corresponding to the remote template.\n   */\n  .directive('ngMessagesInclude',\n    ['$templateRequest', '$document', '$compile', function($templateRequest, $document, $compile) {\n\n    return {\n      restrict: 'AE',\n      require: '^^ngMessages', // we only require this for validation sake\n      link: function($scope, element, attrs) {\n        var src = attrs.ngMessagesInclude || attrs.src;\n        $templateRequest(src).then(function(html) {\n          if ($scope.$$destroyed) return;\n\n          if (isString(html) && !html.trim()) {\n            // Empty template - nothing to compile\n            replaceElementWithMarker(element, src);\n          } else {\n            // Non-empty template - compile and link\n            $compile(html)($scope, function(contents) {\n              element.after(contents);\n              replaceElementWithMarker(element, src);\n            });\n          }\n        });\n      }\n    };\n\n    // Helpers\n    function replaceElementWithMarker(element, src) {\n      // A comment marker is placed for debugging purposes\n      var comment = $compile.$$createComment ?\n          $compile.$$createComment('ngMessagesInclude', src) :\n          $document[0].createComment(' ngMessagesInclude: ' + src + ' ');\n      var marker = jqLite(comment);\n      element.after(marker);\n\n      // Don't pollute the DOM anymore by keeping an empty directive element\n      element.remove();\n    }\n  }])\n\n  /**\n   * @ngdoc directive\n   * @name ngMessage\n   * @restrict AE\n   * @scope\n   * @priority 1\n   *\n   * @description\n   * `ngMessage` is a directive with the purpose to show and hide a particular message.\n   * For `ngMessage` to operate, a parent `ngMessages` directive on a parent DOM element\n   * must be situated since it determines which messages are visible based on the state\n   * of the provided key/value map that `ngMessages` listens on.\n   *\n   * More information about using `ngMessage` can be found in the\n   * {@link module:ngMessages `ngMessages` module documentation}.\n   *\n   * @usage\n   * ```html\n   * <!-- using attribute directives -->\n   * <ANY ng-messages=\"expression\" role=\"alert\">\n   *   <ANY ng-message=\"stringValue\">...</ANY>\n   *   <ANY ng-message=\"stringValue1, stringValue2, ...\">...</ANY>\n   * </ANY>\n   *\n   * <!-- or by using element directives -->\n   * <ng-messages for=\"expression\" role=\"alert\">\n   *   <ng-message when=\"stringValue\">...</ng-message>\n   *   <ng-message when=\"stringValue1, stringValue2, ...\">...</ng-message>\n   * </ng-messages>\n   * ```\n   *\n   * @param {expression} ngMessage|when a string value corresponding to the message key.\n   */\n  .directive('ngMessage', ngMessageDirectiveFactory())\n\n\n  /**\n   * @ngdoc directive\n   * @name ngMessageExp\n   * @restrict AE\n   * @priority 1\n   * @scope\n   *\n   * @description\n   * `ngMessageExp` is the same as {@link directive:ngMessage `ngMessage`}, but instead of a static\n   * value, it accepts an expression to be evaluated for the message key.\n   *\n   * @usage\n   * ```html\n   * <!-- using attribute directives -->\n   * <ANY ng-messages=\"expression\">\n   *   <ANY ng-message-exp=\"expressionValue\">...</ANY>\n   * </ANY>\n   *\n   * <!-- or by using element directives -->\n   * <ng-messages for=\"expression\">\n   *   <ng-message when-exp=\"expressionValue\">...</ng-message>\n   * </ng-messages>\n   * ```\n   *\n   * {@link module:ngMessages Click here} to learn more about `ngMessages` and `ngMessage`.\n   *\n   * @param {expression} ngMessageExp|whenExp an expression value corresponding to the message key.\n   */\n  .directive('ngMessageExp', ngMessageDirectiveFactory());\n\nfunction ngMessageDirectiveFactory() {\n  return ['$animate', function($animate) {\n    return {\n      restrict: 'AE',\n      transclude: 'element',\n      priority: 1, // must run before ngBind, otherwise the text is set on the comment\n      terminal: true,\n      require: '^^ngMessages',\n      link: function(scope, element, attrs, ngMessagesCtrl, $transclude) {\n        var commentNode = element[0];\n\n        var records;\n        var staticExp = attrs.ngMessage || attrs.when;\n        var dynamicExp = attrs.ngMessageExp || attrs.whenExp;\n        var assignRecords = function(items) {\n          records = items\n              ? (isArray(items)\n                  ? items\n                  : items.split(/[\\s,]+/))\n              : null;\n          ngMessagesCtrl.reRender();\n        };\n\n        if (dynamicExp) {\n          assignRecords(scope.$eval(dynamicExp));\n          scope.$watchCollection(dynamicExp, assignRecords);\n        } else {\n          assignRecords(staticExp);\n        }\n\n        var currentElement, messageCtrl;\n        ngMessagesCtrl.register(commentNode, messageCtrl = {\n          test: function(name) {\n            return contains(records, name);\n          },\n          attach: function() {\n            if (!currentElement) {\n              $transclude(function(elm, newScope) {\n                $animate.enter(elm, null, element);\n                currentElement = elm;\n\n                // Each time we attach this node to a message we get a new id that we can match\n                // when we are destroying the node later.\n                var $$attachId = currentElement.$$attachId = ngMessagesCtrl.getAttachId();\n\n                // in the event that the element or a parent element is destroyed\n                // by another structural directive then it's time\n                // to deregister the message from the controller\n                currentElement.on('$destroy', function() {\n                  // If the message element was removed via a call to `detach` then `currentElement` will be null\n                  // So this handler only handles cases where something else removed the message element.\n                  if (currentElement && currentElement.$$attachId === $$attachId) {\n                    ngMessagesCtrl.deregister(commentNode);\n                    messageCtrl.detach();\n                  }\n                  newScope.$destroy();\n                });\n              });\n            }\n          },\n          detach: function() {\n            if (currentElement) {\n              var elm = currentElement;\n              currentElement = null;\n              $animate.leave(elm);\n            }\n          }\n        });\n\n        // We need to ensure that this directive deregisters itself when it no longer exists\n        // Normally this is done when the attached element is destroyed; but if this directive\n        // gets removed before we attach the message to the DOM there is nothing to watch\n        // in which case we must deregister when the containing scope is destroyed.\n        scope.$on('$destroy', function() {\n          ngMessagesCtrl.deregister(commentNode);\n        });\n      }\n    };\n  }];\n\n  function contains(collection, key) {\n    if (collection) {\n      return isArray(collection)\n          ? collection.indexOf(key) >= 0\n          : collection.hasOwnProperty(key);\n    }\n  }\n}\n\n\n})(window, window.angular);\n","require('./angular-messages');\nmodule.exports = 'ngMessages';\n"],"names":["window","angular","forEach","isArray","isString","jqLite","ngMessageDirectiveFactory","$animate","restrict","transclude","priority","terminal","require","link","scope","element","attrs","ngMessagesCtrl","$transclude","records","currentElement","messageCtrl","commentNode","staticExp","ngMessage","when","dynamicExp","ngMessageExp","whenExp","assignRecords","items","split","reRender","$eval","$watchCollection","register","test","name","collection","key","indexOf","hasOwnProperty","contains","attach","elm","newScope","enter","$$attachId","getAttachId","on","deregister","detach","$destroy","leave","$on","module","info","angularVersion","directive","controller","$element","$scope","$attrs","ctrl","this","latestKey","nextAttachId","renderLater","cachedCollection","messages","findPreviousMessage","parent","comment","prevNode","parentLookup","prevKey","$$ngMessageNode","length","childNodes","push","previousSibling","parentNode","render","multiple","isAttrTruthy","ngMessagesMultiple","unmatchedMessages","matchedKeys","messageItem","head","messageFound","totalMessages","message","messageUsed","value","truthy","next","setClass","ngMessages","$evalAsync","nextKey","toString","messageNode","match","insertMessageNode","removeMessageNode","attr","val","$templateRequest","$document","$compile","src","ngMessagesInclude","then","html","$$destroyed","trim","replaceElementWithMarker","contents","after","$$createComment","createComment","marker","remove"],"mappings":"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"}