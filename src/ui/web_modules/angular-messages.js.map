{"version":3,"file":"angular-messages.js","sources":["../node_modules/angular-messages/angular-messages.js","../node_modules/angular-messages/index.js"],"sourcesContent":["/**\n * @license AngularJS v1.8.0\n * (c) 2010-2020 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular) {'use strict';\n\nvar forEach;\nvar isArray;\nvar isString;\nvar jqLite;\n\n/**\n * @ngdoc module\n * @name ngMessages\n * @description\n *\n * The `ngMessages` module provides enhanced support for displaying messages within templates\n * (typically within forms or when rendering message objects that return key/value data).\n * Instead of relying on JavaScript code and/or complex ng-if statements within your form template to\n * show and hide error messages specific to the state of an input field, the `ngMessages` and\n * `ngMessage` directives are designed to handle the complexity, inheritance and priority\n * sequencing based on the order of how the messages are defined in the template.\n *\n * Currently, the ngMessages module only contains the code for the `ngMessages`, `ngMessagesInclude`\n * `ngMessage`, `ngMessageExp` and `ngMessageDefault` directives.\n *\n * ## Usage\n * The `ngMessages` directive allows keys in a key/value collection to be associated with a child element\n * (or 'message') that will show or hide based on the truthiness of that key's value in the collection. A common use\n * case for `ngMessages` is to display error messages for inputs using the `$error` object exposed by the\n * {@link ngModel ngModel} directive.\n *\n * The child elements of the `ngMessages` directive are matched to the collection keys by a `ngMessage` or\n * `ngMessageExp` directive. The value of these attributes must match a key in the collection that is provided by\n * the `ngMessages` directive.\n *\n * Consider the following example, which illustrates a typical use case of `ngMessages`. Within the form `myForm` we\n * have a text input named `myField` which is bound to the scope variable `field` using the {@link ngModel ngModel}\n * directive.\n *\n * The `myField` field is a required input of type `email` with a maximum length of 15 characters.\n *\n * ```html\n * <form name=\"myForm\">\n *   <label>\n *     Enter text:\n *     <input type=\"email\" ng-model=\"field\" name=\"myField\" required maxlength=\"15\" />\n *   </label>\n *   <div ng-messages=\"myForm.myField.$error\" role=\"alert\">\n *     <div ng-message=\"required\">Please enter a value for this field.</div>\n *     <div ng-message=\"email\">This field must be a valid email address.</div>\n *     <div ng-message=\"maxlength\">This field can be at most 15 characters long.</div>\n *   </div>\n * </form>\n * ```\n *\n * In order to show error messages corresponding to `myField` we first create an element with an `ngMessages` attribute\n * set to the `$error` object owned by the `myField` input in our `myForm` form.\n *\n * Within this element we then create separate elements for each of the possible errors that `myField` could have.\n * The `ngMessage` attribute is used to declare which element(s) will appear for which error - for example,\n * setting `ng-message=\"required\"` specifies that this particular element should be displayed when there\n * is no value present for the required field `myField` (because the key `required` will be `true` in the object\n * `myForm.myField.$error`).\n *\n * ### Message order\n *\n * By default, `ngMessages` will only display one message for a particular key/value collection at any time. If more\n * than one message (or error) key is currently true, then which message is shown is determined by the order of messages\n * in the HTML template code (messages declared first are prioritised). This mechanism means the developer does not have\n * to prioritize messages using custom JavaScript code.\n *\n * Given the following error object for our example (which informs us that the field `myField` currently has both the\n * `required` and `email` errors):\n *\n * ```javascript\n * <!-- keep in mind that ngModel automatically sets these error flags -->\n * myField.$error = { required : true, email: true, maxlength: false };\n * ```\n * The `required` message will be displayed to the user since it appears before the `email` message in the DOM.\n * Once the user types a single character, the `required` message will disappear (since the field now has a value)\n * but the `email` message will be visible because it is still applicable.\n *\n * ### Displaying multiple messages at the same time\n *\n * While `ngMessages` will by default only display one error element at a time, the `ng-messages-multiple` attribute can\n * be applied to the `ngMessages` container element to cause it to display all applicable error messages at once:\n *\n * ```html\n * <!-- attribute-style usage -->\n * <div ng-messages=\"myForm.myField.$error\" ng-messages-multiple>...</div>\n *\n * <!-- element-style usage -->\n * <ng-messages for=\"myForm.myField.$error\" multiple>...</ng-messages>\n * ```\n *\n * ## Reusing and Overriding Messages\n * In addition to prioritization, ngMessages also allows for including messages from a remote or an inline\n * template. This allows for generic collection of messages to be reused across multiple parts of an\n * application.\n *\n * ```html\n * <script type=\"text/ng-template\" id=\"error-messages\">\n *   <div ng-message=\"required\">This field is required</div>\n *   <div ng-message=\"minlength\">This field is too short</div>\n * </script>\n *\n * <div ng-messages=\"myForm.myField.$error\" role=\"alert\">\n *   <div ng-messages-include=\"error-messages\"></div>\n * </div>\n * ```\n *\n * However, including generic messages may not be useful enough to match all input fields, therefore,\n * `ngMessages` provides the ability to override messages defined in the remote template by redefining\n * them within the directive container.\n *\n * ```html\n * <!-- a generic template of error messages known as \"my-custom-messages\" -->\n * <script type=\"text/ng-template\" id=\"my-custom-messages\">\n *   <div ng-message=\"required\">This field is required</div>\n *   <div ng-message=\"minlength\">This field is too short</div>\n * </script>\n *\n * <form name=\"myForm\">\n *   <label>\n *     Email address\n *     <input type=\"email\"\n *            id=\"email\"\n *            name=\"myEmail\"\n *            ng-model=\"email\"\n *            minlength=\"5\"\n *            required />\n *   </label>\n *   <!-- any ng-message elements that appear BEFORE the ng-messages-include will\n *        override the messages present in the ng-messages-include template -->\n *   <div ng-messages=\"myForm.myEmail.$error\" role=\"alert\">\n *     <!-- this required message has overridden the template message -->\n *     <div ng-message=\"required\">You did not enter your email address</div>\n *\n *     <!-- this is a brand new message and will appear last in the prioritization -->\n *     <div ng-message=\"email\">Your email address is invalid</div>\n *\n *     <!-- and here are the generic error messages -->\n *     <div ng-messages-include=\"my-custom-messages\"></div>\n *   </div>\n * </form>\n * ```\n *\n * In the example HTML code above the message that is set on required will override the corresponding\n * required message defined within the remote template. Therefore, with particular input fields (such\n * email addresses, date fields, autocomplete inputs, etc...), specialized error messages can be applied\n * while more generic messages can be used to handle other, more general input errors.\n *\n * ## Dynamic Messaging\n * ngMessages also supports using expressions to dynamically change key values. Using arrays and\n * repeaters to list messages is also supported. This means that the code below will be able to\n * fully adapt itself and display the appropriate message when any of the expression data changes:\n *\n * ```html\n * <form name=\"myForm\">\n *   <label>\n *     Email address\n *     <input type=\"email\"\n *            name=\"myEmail\"\n *            ng-model=\"email\"\n *            minlength=\"5\"\n *            required />\n *   </label>\n *   <div ng-messages=\"myForm.myEmail.$error\" role=\"alert\">\n *     <div ng-message=\"required\">You did not enter your email address</div>\n *     <div ng-repeat=\"errorMessage in errorMessages\">\n *       <!-- use ng-message-exp for a message whose key is given by an expression -->\n *       <div ng-message-exp=\"errorMessage.type\">{{ errorMessage.text }}</div>\n *     </div>\n *   </div>\n * </form>\n * ```\n *\n * The `errorMessage.type` expression can be a string value or it can be an array so\n * that multiple errors can be associated with a single error message:\n *\n * ```html\n *   <label>\n *     Email address\n *     <input type=\"email\"\n *            ng-model=\"data.email\"\n *            name=\"myEmail\"\n *            ng-minlength=\"5\"\n *            ng-maxlength=\"100\"\n *            required />\n *   </label>\n *   <div ng-messages=\"myForm.myEmail.$error\" role=\"alert\">\n *     <div ng-message-exp=\"'required'\">You did not enter your email address</div>\n *     <div ng-message-exp=\"['minlength', 'maxlength']\">\n *       Your email must be between 5 and 100 characters long\n *     </div>\n *   </div>\n * ```\n *\n * Feel free to use other structural directives such as ng-if and ng-switch to further control\n * what messages are active and when. Be careful, if you place ng-message on the same element\n * as these structural directives, AngularJS may not be able to determine if a message is active\n * or not. Therefore it is best to place the ng-message on a child element of the structural\n * directive.\n *\n * ```html\n * <div ng-messages=\"myForm.myEmail.$error\" role=\"alert\">\n *   <div ng-if=\"showRequiredError\">\n *     <div ng-message=\"required\">Please enter something</div>\n *   </div>\n * </div>\n * ```\n *\n * ## Animations\n * If the `ngAnimate` module is active within the application then the `ngMessages`, `ngMessage` and\n * `ngMessageExp` directives will trigger animations whenever any messages are added and removed from\n * the DOM by the `ngMessages` directive.\n *\n * Whenever the `ngMessages` directive contains one or more visible messages then the `.ng-active` CSS\n * class will be added to the element. The `.ng-inactive` CSS class will be applied when there are no\n * messages present. Therefore, CSS transitions and keyframes as well as JavaScript animations can\n * hook into the animations whenever these classes are added/removed.\n *\n * Let's say that our HTML code for our messages container looks like so:\n *\n * ```html\n * <div ng-messages=\"myMessages\" class=\"my-messages\" role=\"alert\">\n *   <div ng-message=\"alert\" class=\"some-message\">...</div>\n *   <div ng-message=\"fail\" class=\"some-message\">...</div>\n * </div>\n * ```\n *\n * Then the CSS animation code for the message container looks like so:\n *\n * ```css\n * .my-messages {\n *   transition:1s linear all;\n * }\n * .my-messages.ng-active {\n *   // messages are visible\n * }\n * .my-messages.ng-inactive {\n *   // messages are hidden\n * }\n * ```\n *\n * Whenever an inner message is attached (becomes visible) or removed (becomes hidden) then the enter\n * and leave animation is triggered for each particular element bound to the `ngMessage` directive.\n *\n * Therefore, the CSS code for the inner messages looks like so:\n *\n * ```css\n * .some-message {\n *   transition:1s linear all;\n * }\n *\n * .some-message.ng-enter {}\n * .some-message.ng-enter.ng-enter-active {}\n *\n * .some-message.ng-leave {}\n * .some-message.ng-leave.ng-leave-active {}\n * ```\n *\n * {@link ngAnimate See the ngAnimate docs} to learn how to use JavaScript animations or to learn\n * more about ngAnimate.\n *\n * ## Displaying a default message\n * If the ngMessages renders no inner ngMessage directive (i.e. when none of the truthy\n * keys are matched by a defined message), then it will render a default message\n * using the {@link ngMessageDefault} directive.\n * Note that matched messages will always take precedence over unmatched messages. That means\n * the default message will not be displayed when another message is matched. This is also\n * true for `ng-messages-multiple`.\n *\n * ```html\n * <div ng-messages=\"myForm.myField.$error\" role=\"alert\">\n *   <div ng-message=\"required\">This field is required</div>\n *   <div ng-message=\"minlength\">This field is too short</div>\n *   <div ng-message-default>This field has an input error</div>\n * </div>\n * ```\n *\n\n */\nangular.module('ngMessages', [], function initAngularHelpers() {\n  // Access helpers from AngularJS core.\n  // Do it inside a `config` block to ensure `window.angular` is available.\n  forEach = angular.forEach;\n  isArray = angular.isArray;\n  isString = angular.isString;\n  jqLite = angular.element;\n})\n  .info({ angularVersion: '1.8.0' })\n\n  /**\n   * @ngdoc directive\n   * @module ngMessages\n   * @name ngMessages\n   * @restrict AE\n   *\n   * @description\n   * `ngMessages` is a directive that is designed to show and hide messages based on the state\n   * of a key/value object that it listens on. The directive itself complements error message\n   * reporting with the `ngModel` $error object (which stores a key/value state of validation errors).\n   *\n   * `ngMessages` manages the state of internal messages within its container element. The internal\n   * messages use the `ngMessage` directive and will be inserted/removed from the page depending\n   * on if they're present within the key/value object. By default, only one message will be displayed\n   * at a time and this depends on the prioritization of the messages within the template. (This can\n   * be changed by using the `ng-messages-multiple` or `multiple` attribute on the directive container.)\n   *\n   * A remote template can also be used (With {@link ngMessagesInclude}) to promote message\n   * reusability and messages can also be overridden.\n   *\n   * A default message can also be displayed when no `ngMessage` directive is inserted, using the\n   * {@link ngMessageDefault} directive.\n   *\n   * {@link module:ngMessages Click here} to learn more about `ngMessages` and `ngMessage`.\n   *\n   * @usage\n   * ```html\n   * <!-- using attribute directives -->\n   * <ANY ng-messages=\"expression\" role=\"alert\">\n   *   <ANY ng-message=\"stringValue\">...</ANY>\n   *   <ANY ng-message=\"stringValue1, stringValue2, ...\">...</ANY>\n   *   <ANY ng-message-exp=\"expressionValue\">...</ANY>\n   *   <ANY ng-message-default>...</ANY>\n   * </ANY>\n   *\n   * <!-- or by using element directives -->\n   * <ng-messages for=\"expression\" role=\"alert\">\n   *   <ng-message when=\"stringValue\">...</ng-message>\n   *   <ng-message when=\"stringValue1, stringValue2, ...\">...</ng-message>\n   *   <ng-message when-exp=\"expressionValue\">...</ng-message>\n   *   <ng-message-default>...</ng-message-default>\n   * </ng-messages>\n   * ```\n   *\n   * @param {string} ngMessages an AngularJS expression evaluating to a key/value object\n   *                 (this is typically the $error object on an ngModel instance).\n   * @param {string=} ngMessagesMultiple|multiple when set, all messages will be displayed with true\n   *\n   * @example\n   * <example name=\"ngMessages-directive\" module=\"ngMessagesExample\"\n   *          deps=\"angular-messages.js\"\n   *          animations=\"true\" fixBase=\"true\">\n   *   <file name=\"index.html\">\n   *     <form name=\"myForm\">\n   *       <label>\n   *         Enter your name:\n   *         <input type=\"text\"\n   *                name=\"myName\"\n   *                ng-model=\"name\"\n   *                ng-minlength=\"5\"\n   *                ng-maxlength=\"20\"\n   *                required />\n   *       </label>\n   *       <pre>myForm.myName.$error = {{ myForm.myName.$error | json }}</pre>\n   *\n   *       <div ng-messages=\"myForm.myName.$error\" style=\"color:maroon\" role=\"alert\">\n   *         <div ng-message=\"required\">You did not enter a field</div>\n   *         <div ng-message=\"minlength\">Your field is too short</div>\n   *         <div ng-message=\"maxlength\">Your field is too long</div>\n   *         <div ng-message-default>This field has an input error</div>\n   *       </div>\n   *     </form>\n   *   </file>\n   *   <file name=\"script.js\">\n   *     angular.module('ngMessagesExample', ['ngMessages']);\n   *   </file>\n   * </example>\n   */\n  .directive('ngMessages', ['$animate', function($animate) {\n    var ACTIVE_CLASS = 'ng-active';\n    var INACTIVE_CLASS = 'ng-inactive';\n\n    return {\n      require: 'ngMessages',\n      restrict: 'AE',\n      controller: ['$element', '$scope', '$attrs', function NgMessagesCtrl($element, $scope, $attrs) {\n        var ctrl = this;\n        var latestKey = 0;\n        var nextAttachId = 0;\n\n        this.getAttachId = function getAttachId() { return nextAttachId++; };\n\n        var messages = this.messages = {};\n        var renderLater, cachedCollection;\n\n        this.render = function(collection) {\n          collection = collection || {};\n\n          renderLater = false;\n          cachedCollection = collection;\n\n          // this is true if the attribute is empty or if the attribute value is truthy\n          var multiple = isAttrTruthy($scope, $attrs.ngMessagesMultiple) ||\n                         isAttrTruthy($scope, $attrs.multiple);\n\n          var unmatchedMessages = [];\n          var matchedKeys = {};\n          var truthyKeys = 0;\n          var messageItem = ctrl.head;\n          var messageFound = false;\n          var totalMessages = 0;\n\n          // we use != instead of !== to allow for both undefined and null values\n          while (messageItem != null) {\n            totalMessages++;\n            var messageCtrl = messageItem.message;\n\n            var messageUsed = false;\n            if (!messageFound) {\n              forEach(collection, function(value, key) {\n                if (truthy(value) && !messageUsed) {\n                  truthyKeys++;\n\n                  if (messageCtrl.test(key)) {\n                    // this is to prevent the same error name from showing up twice\n                    if (matchedKeys[key]) return;\n                    matchedKeys[key] = true;\n\n                    messageUsed = true;\n                    messageCtrl.attach();\n                  }\n                }\n              });\n            }\n\n            if (messageUsed) {\n              // unless we want to display multiple messages then we should\n              // set a flag here to avoid displaying the next message in the list\n              messageFound = !multiple;\n            } else {\n              unmatchedMessages.push(messageCtrl);\n            }\n\n            messageItem = messageItem.next;\n          }\n\n          forEach(unmatchedMessages, function(messageCtrl) {\n            messageCtrl.detach();\n          });\n\n          var messageMatched = unmatchedMessages.length !== totalMessages;\n          var attachDefault = ctrl.default && !messageMatched && truthyKeys > 0;\n\n          if (attachDefault) {\n            ctrl.default.attach();\n          } else if (ctrl.default) {\n            ctrl.default.detach();\n          }\n\n          if (messageMatched || attachDefault) {\n            $animate.setClass($element, ACTIVE_CLASS, INACTIVE_CLASS);\n          } else {\n            $animate.setClass($element, INACTIVE_CLASS, ACTIVE_CLASS);\n          }\n        };\n\n        $scope.$watchCollection($attrs.ngMessages || $attrs['for'], ctrl.render);\n\n        this.reRender = function() {\n          if (!renderLater) {\n            renderLater = true;\n            $scope.$evalAsync(function() {\n              if (renderLater && cachedCollection) {\n                ctrl.render(cachedCollection);\n              }\n            });\n          }\n        };\n\n        this.register = function(comment, messageCtrl, isDefault) {\n          if (isDefault) {\n            ctrl.default = messageCtrl;\n          } else {\n            var nextKey = latestKey.toString();\n            messages[nextKey] = {\n              message: messageCtrl\n            };\n            insertMessageNode($element[0], comment, nextKey);\n            comment.$$ngMessageNode = nextKey;\n            latestKey++;\n          }\n\n          ctrl.reRender();\n        };\n\n        this.deregister = function(comment, isDefault) {\n          if (isDefault) {\n            delete ctrl.default;\n          } else {\n            var key = comment.$$ngMessageNode;\n            delete comment.$$ngMessageNode;\n            removeMessageNode($element[0], comment, key);\n            delete messages[key];\n          }\n          ctrl.reRender();\n        };\n\n        function findPreviousMessage(parent, comment) {\n          var prevNode = comment;\n          var parentLookup = [];\n\n          while (prevNode && prevNode !== parent) {\n            var prevKey = prevNode.$$ngMessageNode;\n            if (prevKey && prevKey.length) {\n              return messages[prevKey];\n            }\n\n            // dive deeper into the DOM and examine its children for any ngMessage\n            // comments that may be in an element that appears deeper in the list\n            if (prevNode.childNodes.length && parentLookup.indexOf(prevNode) === -1) {\n              parentLookup.push(prevNode);\n              prevNode = prevNode.childNodes[prevNode.childNodes.length - 1];\n            } else if (prevNode.previousSibling) {\n              prevNode = prevNode.previousSibling;\n            } else {\n              prevNode = prevNode.parentNode;\n              parentLookup.push(prevNode);\n            }\n          }\n        }\n\n        function insertMessageNode(parent, comment, key) {\n          var messageNode = messages[key];\n          if (!ctrl.head) {\n            ctrl.head = messageNode;\n          } else {\n            var match = findPreviousMessage(parent, comment);\n            if (match) {\n              messageNode.next = match.next;\n              match.next = messageNode;\n            } else {\n              messageNode.next = ctrl.head;\n              ctrl.head = messageNode;\n            }\n          }\n        }\n\n        function removeMessageNode(parent, comment, key) {\n          var messageNode = messages[key];\n\n          // This message node may have already been removed by a call to deregister()\n          if (!messageNode) return;\n\n          var match = findPreviousMessage(parent, comment);\n          if (match) {\n            match.next = messageNode.next;\n          } else {\n            ctrl.head = messageNode.next;\n          }\n        }\n      }]\n    };\n\n    function isAttrTruthy(scope, attr) {\n     return (isString(attr) && attr.length === 0) || //empty attribute\n            truthy(scope.$eval(attr));\n    }\n\n    function truthy(val) {\n      return isString(val) ? val.length : !!val;\n    }\n  }])\n\n  /**\n   * @ngdoc directive\n   * @name ngMessagesInclude\n   * @restrict AE\n   * @scope\n   *\n   * @description\n   * `ngMessagesInclude` is a directive with the purpose to import existing ngMessage template\n   * code from a remote template and place the downloaded template code into the exact spot\n   * that the ngMessagesInclude directive is placed within the ngMessages container. This allows\n   * for a series of pre-defined messages to be reused and also allows for the developer to\n   * determine what messages are overridden due to the placement of the ngMessagesInclude directive.\n   *\n   * @usage\n   * ```html\n   * <!-- using attribute directives -->\n   * <ANY ng-messages=\"expression\" role=\"alert\">\n   *   <ANY ng-messages-include=\"remoteTplString\">...</ANY>\n   * </ANY>\n   *\n   * <!-- or by using element directives -->\n   * <ng-messages for=\"expression\" role=\"alert\">\n   *   <ng-messages-include src=\"expressionValue1\">...</ng-messages-include>\n   * </ng-messages>\n   * ```\n   *\n   * {@link module:ngMessages Click here} to learn more about `ngMessages` and `ngMessage`.\n   *\n   * @param {string} ngMessagesInclude|src a string value corresponding to the remote template.\n   */\n  .directive('ngMessagesInclude',\n    ['$templateRequest', '$document', '$compile', function($templateRequest, $document, $compile) {\n\n    return {\n      restrict: 'AE',\n      require: '^^ngMessages', // we only require this for validation sake\n      link: function($scope, element, attrs) {\n        var src = attrs.ngMessagesInclude || attrs.src;\n        $templateRequest(src).then(function(html) {\n          if ($scope.$$destroyed) return;\n\n          if (isString(html) && !html.trim()) {\n            // Empty template - nothing to compile\n            replaceElementWithMarker(element, src);\n          } else {\n            // Non-empty template - compile and link\n            $compile(html)($scope, function(contents) {\n              element.after(contents);\n              replaceElementWithMarker(element, src);\n            });\n          }\n        });\n      }\n    };\n\n    // Helpers\n    function replaceElementWithMarker(element, src) {\n      // A comment marker is placed for debugging purposes\n      var comment = $compile.$$createComment ?\n          $compile.$$createComment('ngMessagesInclude', src) :\n          $document[0].createComment(' ngMessagesInclude: ' + src + ' ');\n      var marker = jqLite(comment);\n      element.after(marker);\n\n      // Don't pollute the DOM anymore by keeping an empty directive element\n      element.remove();\n    }\n  }])\n\n  /**\n   * @ngdoc directive\n   * @name ngMessage\n   * @restrict AE\n   * @scope\n   * @priority 1\n   *\n   * @description\n   * `ngMessage` is a directive with the purpose to show and hide a particular message.\n   * For `ngMessage` to operate, a parent `ngMessages` directive on a parent DOM element\n   * must be situated since it determines which messages are visible based on the state\n   * of the provided key/value map that `ngMessages` listens on.\n   *\n   * More information about using `ngMessage` can be found in the\n   * {@link module:ngMessages `ngMessages` module documentation}.\n   *\n   * @usage\n   * ```html\n   * <!-- using attribute directives -->\n   * <ANY ng-messages=\"expression\" role=\"alert\">\n   *   <ANY ng-message=\"stringValue\">...</ANY>\n   *   <ANY ng-message=\"stringValue1, stringValue2, ...\">...</ANY>\n   * </ANY>\n   *\n   * <!-- or by using element directives -->\n   * <ng-messages for=\"expression\" role=\"alert\">\n   *   <ng-message when=\"stringValue\">...</ng-message>\n   *   <ng-message when=\"stringValue1, stringValue2, ...\">...</ng-message>\n   * </ng-messages>\n   * ```\n   *\n   * @param {expression} ngMessage|when a string value corresponding to the message key.\n   */\n  .directive('ngMessage', ngMessageDirectiveFactory())\n\n\n  /**\n   * @ngdoc directive\n   * @name ngMessageExp\n   * @restrict AE\n   * @priority 1\n   * @scope\n   *\n   * @description\n   * `ngMessageExp` is the same as {@link directive:ngMessage `ngMessage`}, but instead of a static\n   * value, it accepts an expression to be evaluated for the message key.\n   *\n   * @usage\n   * ```html\n   * <!-- using attribute directives -->\n   * <ANY ng-messages=\"expression\">\n   *   <ANY ng-message-exp=\"expressionValue\">...</ANY>\n   * </ANY>\n   *\n   * <!-- or by using element directives -->\n   * <ng-messages for=\"expression\">\n   *   <ng-message when-exp=\"expressionValue\">...</ng-message>\n   * </ng-messages>\n   * ```\n   *\n   * {@link module:ngMessages Click here} to learn more about `ngMessages` and `ngMessage`.\n   *\n   * @param {expression} ngMessageExp|whenExp an expression value corresponding to the message key.\n   */\n  .directive('ngMessageExp', ngMessageDirectiveFactory())\n\n  /**\n   * @ngdoc directive\n   * @name ngMessageDefault\n   * @restrict AE\n   * @scope\n   *\n   * @description\n   * `ngMessageDefault` is a directive with the purpose to show and hide a default message for\n   * {@link directive:ngMessages}, when none of provided messages matches.\n   *\n   * More information about using `ngMessageDefault` can be found in the\n   * {@link module:ngMessages `ngMessages` module documentation}.\n   *\n   * @usage\n   * ```html\n   * <!-- using attribute directives -->\n   * <ANY ng-messages=\"expression\" role=\"alert\">\n   *   <ANY ng-message=\"stringValue\">...</ANY>\n   *   <ANY ng-message=\"stringValue1, stringValue2, ...\">...</ANY>\n   *   <ANY ng-message-default>...</ANY>\n   * </ANY>\n   *\n   * <!-- or by using element directives -->\n   * <ng-messages for=\"expression\" role=\"alert\">\n   *   <ng-message when=\"stringValue\">...</ng-message>\n   *   <ng-message when=\"stringValue1, stringValue2, ...\">...</ng-message>\n   *   <ng-message-default>...</ng-message-default>\n   * </ng-messages>\n   *\n  */\n  .directive('ngMessageDefault', ngMessageDirectiveFactory(true));\n\nfunction ngMessageDirectiveFactory(isDefault) {\n  return ['$animate', function($animate) {\n    return {\n      restrict: 'AE',\n      transclude: 'element',\n      priority: 1, // must run before ngBind, otherwise the text is set on the comment\n      terminal: true,\n      require: '^^ngMessages',\n      link: function(scope, element, attrs, ngMessagesCtrl, $transclude) {\n        var commentNode, records, staticExp, dynamicExp;\n\n        if (!isDefault) {\n          commentNode = element[0];\n          staticExp = attrs.ngMessage || attrs.when;\n          dynamicExp = attrs.ngMessageExp || attrs.whenExp;\n\n          var assignRecords = function(items) {\n            records = items\n                ? (isArray(items)\n                      ? items\n                      : items.split(/[\\s,]+/))\n                : null;\n            ngMessagesCtrl.reRender();\n          };\n\n          if (dynamicExp) {\n            assignRecords(scope.$eval(dynamicExp));\n            scope.$watchCollection(dynamicExp, assignRecords);\n          } else {\n            assignRecords(staticExp);\n          }\n        }\n\n        var currentElement, messageCtrl;\n        ngMessagesCtrl.register(commentNode, messageCtrl = {\n          test: function(name) {\n            return contains(records, name);\n          },\n          attach: function() {\n            if (!currentElement) {\n              $transclude(function(elm, newScope) {\n                $animate.enter(elm, null, element);\n                currentElement = elm;\n\n                // Each time we attach this node to a message we get a new id that we can match\n                // when we are destroying the node later.\n                var $$attachId = currentElement.$$attachId = ngMessagesCtrl.getAttachId();\n\n                // in the event that the element or a parent element is destroyed\n                // by another structural directive then it's time\n                // to deregister the message from the controller\n                currentElement.on('$destroy', function() {\n                  // If the message element was removed via a call to `detach` then `currentElement` will be null\n                  // So this handler only handles cases where something else removed the message element.\n                  if (currentElement && currentElement.$$attachId === $$attachId) {\n                    ngMessagesCtrl.deregister(commentNode, isDefault);\n                    messageCtrl.detach();\n                  }\n                  newScope.$destroy();\n                });\n              });\n            }\n          },\n          detach: function() {\n            if (currentElement) {\n              var elm = currentElement;\n              currentElement = null;\n              $animate.leave(elm);\n            }\n          }\n        }, isDefault);\n\n        // We need to ensure that this directive deregisters itself when it no longer exists\n        // Normally this is done when the attached element is destroyed; but if this directive\n        // gets removed before we attach the message to the DOM there is nothing to watch\n        // in which case we must deregister when the containing scope is destroyed.\n        scope.$on('$destroy', function() {\n          ngMessagesCtrl.deregister(commentNode, isDefault);\n        });\n      }\n    };\n  }];\n\n  function contains(collection, key) {\n    if (collection) {\n      return isArray(collection)\n          ? collection.indexOf(key) >= 0\n          : collection.hasOwnProperty(key);\n    }\n  }\n}\n\n\n})(window, window.angular);\n","require('./angular-messages');\nmodule.exports = 'ngMessages';\n"],"names":["window","angular","forEach","isArray","isString","jqLite","ngMessageDirectiveFactory","isDefault","$animate","restrict","transclude","priority","terminal","require","link","scope","element","attrs","ngMessagesCtrl","$transclude","commentNode","records","staticExp","dynamicExp","currentElement","messageCtrl","ngMessage","when","assignRecords","items","split","reRender","ngMessageExp","whenExp","$eval","$watchCollection","register","test","name","collection","key","indexOf","hasOwnProperty","contains","attach","elm","newScope","enter","$$attachId","getAttachId","on","deregister","detach","$destroy","leave","$on","module","info","angularVersion","directive","controller","$element","$scope","$attrs","ctrl","this","latestKey","nextAttachId","renderLater","cachedCollection","messages","findPreviousMessage","parent","comment","prevNode","parentLookup","prevKey","$$ngMessageNode","length","childNodes","push","previousSibling","parentNode","render","multiple","isAttrTruthy","ngMessagesMultiple","unmatchedMessages","matchedKeys","truthyKeys","messageItem","head","messageFound","totalMessages","message","messageUsed","value","truthy","next","messageMatched","attachDefault","default","setClass","ngMessages","$evalAsync","nextKey","toString","messageNode","match","insertMessageNode","removeMessageNode","attr","val","$templateRequest","$document","$compile","src","ngMessagesInclude","then","html","$$destroyed","trim","replaceElementWithMarker","contents","after","$$createComment","createComment","marker","remove"],"mappings":"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"}