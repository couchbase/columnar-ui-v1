{"version":3,"file":"angularjs.js","sources":["../../node_modules/@uirouter/angularjs/lib-esm/angular.js","../../node_modules/@uirouter/angularjs/lib-esm/statebuilders/views.js","../../node_modules/@uirouter/angularjs/lib-esm/templateFactory.js","../../node_modules/@uirouter/angularjs/lib-esm/stateProvider.js","../../node_modules/@uirouter/angularjs/lib-esm/statebuilders/onEnterExitRetain.js","../../node_modules/@uirouter/angularjs/lib-esm/locationServices.js","../../node_modules/@uirouter/angularjs/lib-esm/urlRouterProvider.js","../../node_modules/@uirouter/angularjs/lib-esm/services.js","../../node_modules/@uirouter/angularjs/lib-esm/directives/stateDirectives.js","../../node_modules/@uirouter/angularjs/lib-esm/directives/viewDirective.js","../../node_modules/@uirouter/angularjs/lib-esm/stateFilters.js","../../node_modules/@uirouter/angularjs/lib-esm/viewScroll.js","../../node_modules/@uirouter/angularjs/lib-esm/index.js"],"sourcesContent":["/** @publicapi @module ng1 */ /** */\nimport * as ng_from_import from 'angular';\n/** @hidden */ var ng_from_global = angular;\n/** @hidden */ export var ng = ng_from_import && ng_from_import.module ? ng_from_import : ng_from_global;\n//# sourceMappingURL=angular.js.map","import { pick, forEach, tail, extend, isArray, isInjectable, isDefined, isString, services, trace, ViewService, ResolveContext, Resolvable, } from '@uirouter/core';\n/** @internalapi */\nexport function getNg1ViewConfigFactory() {\n    var templateFactory = null;\n    return function (path, view) {\n        templateFactory = templateFactory || services.$injector.get('$templateFactory');\n        return [new Ng1ViewConfig(path, view, templateFactory)];\n    };\n}\n/** @internalapi */\nvar hasAnyKey = function (keys, obj) { return keys.reduce(function (acc, key) { return acc || isDefined(obj[key]); }, false); };\n/**\n * This is a [[StateBuilder.builder]] function for angular1 `views`.\n *\n * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder\n * handles the `views` property with logic specific to @uirouter/angularjs (ng1).\n *\n * If no `views: {}` property exists on the [[StateDeclaration]], then it creates the `views` object\n * and applies the state-level configuration to a view named `$default`.\n *\n * @internalapi\n */\nexport function ng1ViewsBuilder(state) {\n    // Do not process root state\n    if (!state.parent)\n        return {};\n    var tplKeys = ['templateProvider', 'templateUrl', 'template', 'notify', 'async'], ctrlKeys = ['controller', 'controllerProvider', 'controllerAs', 'resolveAs'], compKeys = ['component', 'bindings', 'componentProvider'], nonCompKeys = tplKeys.concat(ctrlKeys), allViewKeys = compKeys.concat(nonCompKeys);\n    // Do not allow a state to have both state-level props and also a `views: {}` property.\n    // A state without a `views: {}` property can declare properties for the `$default` view as properties of the state.\n    // However, the `$default` approach should not be mixed with a separate `views: ` block.\n    if (isDefined(state.views) && hasAnyKey(allViewKeys, state)) {\n        throw new Error(\"State '\" + state.name + \"' has a 'views' object. \" +\n            \"It cannot also have \\\"view properties\\\" at the state level.  \" +\n            \"Move the following properties into a view (in the 'views' object): \" +\n            (\" \" + allViewKeys.filter(function (key) { return isDefined(state[key]); }).join(', ')));\n    }\n    var views = {}, viewsObject = state.views || { $default: pick(state, allViewKeys) };\n    forEach(viewsObject, function (config, name) {\n        // Account for views: { \"\": { template... } }\n        name = name || '$default';\n        // Account for views: { header: \"headerComponent\" }\n        if (isString(config))\n            config = { component: config };\n        // Make a shallow copy of the config object\n        config = extend({}, config);\n        // Do not allow a view to mix props for component-style view with props for template/controller-style view\n        if (hasAnyKey(compKeys, config) && hasAnyKey(nonCompKeys, config)) {\n            throw new Error(\"Cannot combine: \" + compKeys.join('|') + \" with: \" + nonCompKeys.join('|') + \" in stateview: '\" + name + \"@\" + state.name + \"'\");\n        }\n        config.resolveAs = config.resolveAs || '$resolve';\n        config.$type = 'ng1';\n        config.$context = state;\n        config.$name = name;\n        var normalized = ViewService.normalizeUIViewTarget(config.$context, config.$name);\n        config.$uiViewName = normalized.uiViewName;\n        config.$uiViewContextAnchor = normalized.uiViewContextAnchor;\n        views[name] = config;\n    });\n    return views;\n}\n/** @hidden */\nvar id = 0;\n/** @internalapi */\nvar Ng1ViewConfig = /** @class */ (function () {\n    function Ng1ViewConfig(path, viewDecl, factory) {\n        var _this = this;\n        this.path = path;\n        this.viewDecl = viewDecl;\n        this.factory = factory;\n        this.$id = id++;\n        this.loaded = false;\n        this.getTemplate = function (uiView, context) {\n            return _this.component\n                ? _this.factory.makeComponentTemplate(uiView, context, _this.component, _this.viewDecl.bindings)\n                : _this.template;\n        };\n    }\n    Ng1ViewConfig.prototype.load = function () {\n        var _this = this;\n        var $q = services.$q;\n        var context = new ResolveContext(this.path);\n        var params = this.path.reduce(function (acc, node) { return extend(acc, node.paramValues); }, {});\n        var promises = {\n            template: $q.when(this.factory.fromConfig(this.viewDecl, params, context)),\n            controller: $q.when(this.getController(context)),\n        };\n        return $q.all(promises).then(function (results) {\n            trace.traceViewServiceEvent('Loaded', _this);\n            _this.controller = results.controller;\n            extend(_this, results.template); // Either { template: \"tpl\" } or { component: \"cmpName\" }\n            return _this;\n        });\n    };\n    /**\n     * Gets the controller for a view configuration.\n     *\n     * @returns {Function|Promise.<Function>} Returns a controller, or a promise that resolves to a controller.\n     */\n    Ng1ViewConfig.prototype.getController = function (context) {\n        var provider = this.viewDecl.controllerProvider;\n        if (!isInjectable(provider))\n            return this.viewDecl.controller;\n        var deps = services.$injector.annotate(provider);\n        var providerFn = isArray(provider) ? tail(provider) : provider;\n        var resolvable = new Resolvable('', providerFn, deps);\n        return resolvable.get(context);\n    };\n    return Ng1ViewConfig;\n}());\nexport { Ng1ViewConfig };\n//# sourceMappingURL=views.js.map","/** @publicapi @module view */ /** */\nimport { ng as angular } from './angular';\nimport { isArray, isDefined, isFunction, isObject, services, tail, kebobString, unnestR, Resolvable, } from '@uirouter/core';\n/**\n * Service which manages loading of templates from a ViewConfig.\n */\nvar TemplateFactory = /** @class */ (function () {\n    function TemplateFactory() {\n        var _this = this;\n        /** @hidden */ this._useHttp = angular.version.minor < 3;\n        /** @hidden */ this.$get = [\n            '$http',\n            '$templateCache',\n            '$injector',\n            function ($http, $templateCache, $injector) {\n                _this.$templateRequest = $injector.has && $injector.has('$templateRequest') && $injector.get('$templateRequest');\n                _this.$http = $http;\n                _this.$templateCache = $templateCache;\n                return _this;\n            },\n        ];\n    }\n    /** @hidden */\n    TemplateFactory.prototype.useHttpService = function (value) {\n        this._useHttp = value;\n    };\n    /**\n     * Creates a template from a configuration object.\n     *\n     * @param config Configuration object for which to load a template.\n     * The following properties are search in the specified order, and the first one\n     * that is defined is used to create the template:\n     *\n     * @param params  Parameters to pass to the template function.\n     * @param context The resolve context associated with the template's view\n     *\n     * @return {string|object}  The template html as a string, or a promise for\n     * that string,or `null` if no template is configured.\n     */\n    TemplateFactory.prototype.fromConfig = function (config, params, context) {\n        var defaultTemplate = '<ui-view></ui-view>';\n        var asTemplate = function (result) { return services.$q.when(result).then(function (str) { return ({ template: str }); }); };\n        var asComponent = function (result) { return services.$q.when(result).then(function (str) { return ({ component: str }); }); };\n        return isDefined(config.template)\n            ? asTemplate(this.fromString(config.template, params))\n            : isDefined(config.templateUrl)\n                ? asTemplate(this.fromUrl(config.templateUrl, params))\n                : isDefined(config.templateProvider)\n                    ? asTemplate(this.fromProvider(config.templateProvider, params, context))\n                    : isDefined(config.component)\n                        ? asComponent(config.component)\n                        : isDefined(config.componentProvider)\n                            ? asComponent(this.fromComponentProvider(config.componentProvider, params, context))\n                            : asTemplate(defaultTemplate);\n    };\n    /**\n     * Creates a template from a string or a function returning a string.\n     *\n     * @param template html template as a string or function that returns an html template as a string.\n     * @param params Parameters to pass to the template function.\n     *\n     * @return {string|object} The template html as a string, or a promise for that\n     * string.\n     */\n    TemplateFactory.prototype.fromString = function (template, params) {\n        return isFunction(template) ? template(params) : template;\n    };\n    /**\n     * Loads a template from the a URL via `$http` and `$templateCache`.\n     *\n     * @param {string|Function} url url of the template to load, or a function\n     * that returns a url.\n     * @param {Object} params Parameters to pass to the url function.\n     * @return {string|Promise.<string>} The template html as a string, or a promise\n     * for that string.\n     */\n    TemplateFactory.prototype.fromUrl = function (url, params) {\n        if (isFunction(url))\n            url = url(params);\n        if (url == null)\n            return null;\n        if (this._useHttp) {\n            return this.$http\n                .get(url, { cache: this.$templateCache, headers: { Accept: 'text/html' } })\n                .then(function (response) {\n                return response.data;\n            });\n        }\n        return this.$templateRequest(url);\n    };\n    /**\n     * Creates a template by invoking an injectable provider function.\n     *\n     * @param provider Function to invoke via `locals`\n     * @param {Function} injectFn a function used to invoke the template provider\n     * @return {string|Promise.<string>} The template html as a string, or a promise\n     * for that string.\n     */\n    TemplateFactory.prototype.fromProvider = function (provider, params, context) {\n        var deps = services.$injector.annotate(provider);\n        var providerFn = isArray(provider) ? tail(provider) : provider;\n        var resolvable = new Resolvable('', providerFn, deps);\n        return resolvable.get(context);\n    };\n    /**\n     * Creates a component's template by invoking an injectable provider function.\n     *\n     * @param provider Function to invoke via `locals`\n     * @param {Function} injectFn a function used to invoke the template provider\n     * @return {string} The template html as a string: \"<component-name input1='::$resolve.foo'></component-name>\".\n     */\n    TemplateFactory.prototype.fromComponentProvider = function (provider, params, context) {\n        var deps = services.$injector.annotate(provider);\n        var providerFn = isArray(provider) ? tail(provider) : provider;\n        var resolvable = new Resolvable('', providerFn, deps);\n        return resolvable.get(context);\n    };\n    /**\n     * Creates a template from a component's name\n     *\n     * This implements route-to-component.\n     * It works by retrieving the component (directive) metadata from the injector.\n     * It analyses the component's bindings, then constructs a template that instantiates the component.\n     * The template wires input and output bindings to resolves or from the parent component.\n     *\n     * @param uiView {object} The parent ui-view (for binding outputs to callbacks)\n     * @param context The ResolveContext (for binding outputs to callbacks returned from resolves)\n     * @param component {string} Component's name in camel case.\n     * @param bindings An object defining the component's bindings: {foo: '<'}\n     * @return {string} The template as a string: \"<component-name input1='::$resolve.foo'></component-name>\".\n     */\n    TemplateFactory.prototype.makeComponentTemplate = function (uiView, context, component, bindings) {\n        bindings = bindings || {};\n        // Bind once prefix\n        var prefix = angular.version.minor >= 3 ? '::' : '';\n        // Convert to kebob name. Add x- prefix if the string starts with `x-` or `data-`\n        var kebob = function (camelCase) {\n            var kebobed = kebobString(camelCase);\n            return /^(x|data)-/.exec(kebobed) ? \"x-\" + kebobed : kebobed;\n        };\n        var attributeTpl = function (input) {\n            var name = input.name, type = input.type;\n            var attrName = kebob(name);\n            // If the ui-view has an attribute which matches a binding on the routed component\n            // then pass that attribute through to the routed component template.\n            // Prefer ui-view wired mappings to resolve data, unless the resolve was explicitly bound using `bindings:`\n            if (uiView.attr(attrName) && !bindings[name])\n                return attrName + \"='\" + uiView.attr(attrName) + \"'\";\n            var resolveName = bindings[name] || name;\n            // Pre-evaluate the expression for \"@\" bindings by enclosing in {{ }}\n            // some-attr=\"{{ ::$resolve.someResolveName }}\"\n            if (type === '@')\n                return attrName + \"='{{\" + prefix + \"$resolve.\" + resolveName + \"}}'\";\n            // Wire \"&\" callbacks to resolves that return a callback function\n            // Get the result of the resolve (should be a function) and annotate it to get its arguments.\n            // some-attr=\"$resolve.someResolveResultName(foo, bar)\"\n            if (type === '&') {\n                var res = context.getResolvable(resolveName);\n                var fn = res && res.data;\n                var args = (fn && services.$injector.annotate(fn)) || [];\n                // account for array style injection, i.e., ['foo', function(foo) {}]\n                var arrayIdxStr = isArray(fn) ? \"[\" + (fn.length - 1) + \"]\" : '';\n                return attrName + \"='$resolve.\" + resolveName + arrayIdxStr + \"(\" + args.join(',') + \")'\";\n            }\n            // some-attr=\"::$resolve.someResolveName\"\n            return attrName + \"='\" + prefix + \"$resolve.\" + resolveName + \"'\";\n        };\n        var attrs = getComponentBindings(component)\n            .map(attributeTpl)\n            .join(' ');\n        var kebobName = kebob(component);\n        return \"<\" + kebobName + \" \" + attrs + \"></\" + kebobName + \">\";\n    };\n    return TemplateFactory;\n}());\nexport { TemplateFactory };\n// Gets all the directive(s)' inputs ('@', '=', and '<') and outputs ('&')\nfunction getComponentBindings(name) {\n    var cmpDefs = services.$injector.get(name + 'Directive'); // could be multiple\n    if (!cmpDefs || !cmpDefs.length)\n        throw new Error(\"Unable to find component named '\" + name + \"'\");\n    return cmpDefs.map(getBindings).reduce(unnestR, []);\n}\n// Given a directive definition, find its object input attributes\n// Use different properties, depending on the type of directive (component, bindToController, normal)\nvar getBindings = function (def) {\n    if (isObject(def.bindToController))\n        return scopeBindings(def.bindToController);\n    return scopeBindings(def.scope);\n};\n// for ng 1.2 style, process the scope: { input: \"=foo\" }\n// for ng 1.3 through ng 1.5, process the component's bindToController: { input: \"=foo\" } object\nvar scopeBindings = function (bindingsObj) {\n    return Object.keys(bindingsObj || {})\n        // [ 'input', [ '=foo', '=', 'foo' ] ]\n        .map(function (key) { return [key, /^([=<@&])[?]?(.*)/.exec(bindingsObj[key])]; })\n        // skip malformed values\n        .filter(function (tuple) { return isDefined(tuple) && isArray(tuple[1]); })\n        // { name: ('foo' || 'input'), type: '=' }\n        .map(function (tuple) { return ({ name: tuple[1][2] || tuple[0], type: tuple[1][1] }); });\n};\n//# sourceMappingURL=templateFactory.js.map","/** @publicapi @module ng1 */ /** */\nimport { val, isObject, createProxyFunctions, } from '@uirouter/core';\n/**\n * The Angular 1 `StateProvider`\n *\n * The `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n * on state.\n *\n * A state corresponds to a \"place\" in the application in terms of the overall UI and\n * navigation. A state describes (via the controller / template / view properties) what\n * the UI looks like and does at that place.\n *\n * States often have things in common, and the primary way of factoring out these\n * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n * nested states.\n *\n * The `$stateProvider` provides interfaces to declare these states for your app.\n */\nvar StateProvider = /** @class */ (function () {\n    function StateProvider(stateRegistry, stateService) {\n        this.stateRegistry = stateRegistry;\n        this.stateService = stateService;\n        createProxyFunctions(val(StateProvider.prototype), this, val(this));\n    }\n    /**\n     * Decorates states when they are registered\n     *\n     * Allows you to extend (carefully) or override (at your own peril) the\n     * `stateBuilder` object used internally by [[StateRegistry]].\n     * This can be used to add custom functionality to ui-router,\n     * for example inferring templateUrl based on the state name.\n     *\n     * When passing only a name, it returns the current (original or decorated) builder\n     * function that matches `name`.\n     *\n     * The builder functions that can be decorated are listed below. Though not all\n     * necessarily have a good use case for decoration, that is up to you to decide.\n     *\n     * In addition, users can attach custom decorators, which will generate new\n     * properties within the state's internal definition. There is currently no clear\n     * use-case for this beyond accessing internal states (i.e. $state.$current),\n     * however, expect this to become increasingly relevant as we introduce additional\n     * meta-programming features.\n     *\n     * **Warning**: Decorators should not be interdependent because the order of\n     * execution of the builder functions in non-deterministic. Builder functions\n     * should only be dependent on the state definition object and super function.\n     *\n     *\n     * Existing builder functions and current return values:\n     *\n     * - **parent** `{object}` - returns the parent state object.\n     * - **data** `{object}` - returns state data, including any inherited data that is not\n     *   overridden by own values (if any).\n     * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n     *   or `null`.\n     * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is\n     *   navigable).\n     * - **params** `{object}` - returns an array of state params that are ensured to\n     *   be a super-set of parent's params.\n     * - **views** `{object}` - returns a views object where each key is an absolute view\n     *   name (i.e. \"viewName@stateName\") and each value is the config object\n     *   (template, controller) for the view. Even when you don't use the views object\n     *   explicitly on a state config, one is still created for you internally.\n     *   So by decorating this builder function you have access to decorating template\n     *   and controller properties.\n     * - **ownParams** `{object}` - returns an array of params that belong to the state,\n     *   not including any params defined by ancestor states.\n     * - **path** `{string}` - returns the full path from the root down to this state.\n     *   Needed for state activation.\n     * - **includes** `{object}` - returns an object that includes every state that\n     *   would pass a `$state.includes()` test.\n     *\n     * #### Example:\n     * Override the internal 'views' builder with a function that takes the state\n     * definition, and a reference to the internal function being overridden:\n     * ```js\n     * $stateProvider.decorator('views', function (state, parent) {\n     *   let result = {},\n     *       views = parent(state);\n     *\n     *   angular.forEach(views, function (config, name) {\n     *     let autoName = (state.name + '.' + name).replace('.', '/');\n     *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n     *     result[name] = config;\n     *   });\n     *   return result;\n     * });\n     *\n     * $stateProvider.state('home', {\n     *   views: {\n     *     'contact.list': { controller: 'ListController' },\n     *     'contact.item': { controller: 'ItemController' }\n     *   }\n     * });\n     * ```\n     *\n     *\n     * ```js\n     * // Auto-populates list and item views with /partials/home/contact/list.html,\n     * // and /partials/home/contact/item.html, respectively.\n     * $state.go('home');\n     * ```\n     *\n     * @param {string} name The name of the builder function to decorate.\n     * @param {object} func A function that is responsible for decorating the original\n     * builder function. The function receives two parameters:\n     *\n     *   - `{object}` - state - The state config object.\n     *   - `{object}` - super - The original builder function.\n     *\n     * @return {object} $stateProvider - $stateProvider instance\n     */\n    StateProvider.prototype.decorator = function (name, func) {\n        return this.stateRegistry.decorator(name, func) || this;\n    };\n    StateProvider.prototype.state = function (name, definition) {\n        if (isObject(name)) {\n            definition = name;\n        }\n        else {\n            definition.name = name;\n        }\n        this.stateRegistry.register(definition);\n        return this;\n    };\n    /**\n     * Registers an invalid state handler\n     *\n     * This is a passthrough to [[StateService.onInvalid]] for ng1.\n     */\n    StateProvider.prototype.onInvalid = function (callback) {\n        return this.stateService.onInvalid(callback);\n    };\n    return StateProvider;\n}());\nexport { StateProvider };\n//# sourceMappingURL=stateProvider.js.map","/** @publicapi @module ng1 */ /** */\nimport { services, ResolveContext, extend, } from '@uirouter/core';\nimport { getLocals } from '../services';\n/**\n * This is a [[StateBuilder.builder]] function for angular1 `onEnter`, `onExit`,\n * `onRetain` callback hooks on a [[Ng1StateDeclaration]].\n *\n * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder\n * ensures that those hooks are injectable for @uirouter/angularjs (ng1).\n *\n * @internalapi\n */\nexport var getStateHookBuilder = function (hookName) {\n    return function stateHookBuilder(stateObject, parentFn) {\n        var hook = stateObject[hookName];\n        var pathname = hookName === 'onExit' ? 'from' : 'to';\n        function decoratedNg1Hook(trans, state) {\n            var resolveContext = new ResolveContext(trans.treeChanges(pathname));\n            var subContext = resolveContext.subContext(state.$$state());\n            var locals = extend(getLocals(subContext), { $state$: state, $transition$: trans });\n            return services.$injector.invoke(hook, this, locals);\n        }\n        return hook ? decoratedNg1Hook : undefined;\n    };\n};\n//# sourceMappingURL=onEnterExitRetain.js.map","/** @publicapi @module ng1 */ /** */\nimport { isDefined } from '@uirouter/core';\nimport { val, createProxyFunctions, removeFrom, isObject } from '@uirouter/core';\n/**\n * Implements UI-Router LocationServices and LocationConfig using Angular 1's $location service\n * @internalapi\n */\nvar Ng1LocationServices = /** @class */ (function () {\n    function Ng1LocationServices($locationProvider) {\n        // .onChange() registry\n        this._urlListeners = [];\n        this.$locationProvider = $locationProvider;\n        var _lp = val($locationProvider);\n        createProxyFunctions(_lp, this, _lp, ['hashPrefix']);\n    }\n    /**\n     * Applys ng1-specific path parameter encoding\n     *\n     * The Angular 1 `$location` service is a bit weird.\n     * It doesn't allow slashes to be encoded/decoded bi-directionally.\n     *\n     * See the writeup at https://github.com/angular-ui/ui-router/issues/2598\n     *\n     * This code patches the `path` parameter type so it encoded/decodes slashes as ~2F\n     *\n     * @param router\n     */\n    Ng1LocationServices.monkeyPatchPathParameterType = function (router) {\n        var pathType = router.urlMatcherFactory.type('path');\n        pathType.encode = function (x) {\n            return x != null ? x.toString().replace(/(~|\\/)/g, function (m) { return ({ '~': '~~', '/': '~2F' }[m]); }) : x;\n        };\n        pathType.decode = function (x) {\n            return x != null ? x.toString().replace(/(~~|~2F)/g, function (m) { return ({ '~~': '~', '~2F': '/' }[m]); }) : x;\n        };\n    };\n    Ng1LocationServices.prototype.dispose = function () { };\n    Ng1LocationServices.prototype.onChange = function (callback) {\n        var _this = this;\n        this._urlListeners.push(callback);\n        return function () { return removeFrom(_this._urlListeners)(callback); };\n    };\n    Ng1LocationServices.prototype.html5Mode = function () {\n        var html5Mode = this.$locationProvider.html5Mode();\n        html5Mode = isObject(html5Mode) ? html5Mode.enabled : html5Mode;\n        return html5Mode && this.$sniffer.history;\n    };\n    Ng1LocationServices.prototype.baseHref = function () {\n        return this._baseHref || (this._baseHref = this.$browser.baseHref() || this.$window.location.pathname);\n    };\n    Ng1LocationServices.prototype.url = function (newUrl, replace, state) {\n        if (replace === void 0) { replace = false; }\n        if (isDefined(newUrl))\n            this.$location.url(newUrl);\n        if (replace)\n            this.$location.replace();\n        if (state)\n            this.$location.state(state);\n        return this.$location.url();\n    };\n    Ng1LocationServices.prototype._runtimeServices = function ($rootScope, $location, $sniffer, $browser, $window) {\n        var _this = this;\n        this.$location = $location;\n        this.$sniffer = $sniffer;\n        this.$browser = $browser;\n        this.$window = $window;\n        // Bind $locationChangeSuccess to the listeners registered in LocationService.onChange\n        $rootScope.$on('$locationChangeSuccess', function (evt) { return _this._urlListeners.forEach(function (fn) { return fn(evt); }); });\n        var _loc = val($location);\n        // Bind these LocationService functions to $location\n        createProxyFunctions(_loc, this, _loc, ['replace', 'path', 'search', 'hash']);\n        // Bind these LocationConfig functions to $location\n        createProxyFunctions(_loc, this, _loc, ['port', 'protocol', 'host']);\n    };\n    return Ng1LocationServices;\n}());\nexport { Ng1LocationServices };\n//# sourceMappingURL=locationServices.js.map","/** @publicapi @module url */ /** */\nimport { BaseUrlRule, } from '@uirouter/core';\nimport { services, isString, isFunction, isArray, identity } from '@uirouter/core';\n/**\n * Manages rules for client-side URL\n *\n * ### Deprecation warning:\n * This class is now considered to be an internal API\n * Use the [[UrlService]] instead.\n * For configuring URL rules, use the [[UrlRulesApi]] which can be found as [[UrlService.rules]].\n *\n * This class manages the router rules for what to do when the URL changes.\n *\n * This provider remains for backwards compatibility.\n *\n * @internalapi\n * @deprecated\n */\nvar UrlRouterProvider = /** @class */ (function () {\n    /** @hidden */\n    function UrlRouterProvider(/** @hidden */ router) {\n        this.router = router;\n    }\n    UrlRouterProvider.injectableHandler = function (router, handler) {\n        return function (match) { return services.$injector.invoke(handler, null, { $match: match, $stateParams: router.globals.params }); };\n    };\n    /** @hidden */\n    UrlRouterProvider.prototype.$get = function () {\n        var urlService = this.router.urlService;\n        this.router.urlRouter.update(true);\n        if (!urlService.interceptDeferred)\n            urlService.listen();\n        return this.router.urlRouter;\n    };\n    /**\n     * Registers a url handler function.\n     *\n     * Registers a low level url handler (a `rule`).\n     * A rule detects specific URL patterns and returns a redirect, or performs some action.\n     *\n     * If a rule returns a string, the URL is replaced with the string, and all rules are fired again.\n     *\n     * #### Example:\n     * ```js\n     * var app = angular.module('app', ['ui.router.router']);\n     *\n     * app.config(function ($urlRouterProvider) {\n     *   // Here's an example of how you might allow case insensitive urls\n     *   $urlRouterProvider.rule(function ($injector, $location) {\n     *     var path = $location.path(),\n     *         normalized = path.toLowerCase();\n     *\n     *     if (path !== normalized) {\n     *       return normalized;\n     *     }\n     *   });\n     * });\n     * ```\n     *\n     * @param ruleFn\n     * Handler function that takes `$injector` and `$location` services as arguments.\n     * You can use them to detect a url and return a different url as a string.\n     *\n     * @return [[UrlRouterProvider]] (`this`)\n     */\n    UrlRouterProvider.prototype.rule = function (ruleFn) {\n        var _this = this;\n        if (!isFunction(ruleFn))\n            throw new Error(\"'rule' must be a function\");\n        var match = function () { return ruleFn(services.$injector, _this.router.locationService); };\n        var rule = new BaseUrlRule(match, identity);\n        this.router.urlService.rules.rule(rule);\n        return this;\n    };\n    /**\n     * Defines the path or behavior to use when no url can be matched.\n     *\n     * #### Example:\n     * ```js\n     * var app = angular.module('app', ['ui.router.router']);\n     *\n     * app.config(function ($urlRouterProvider) {\n     *   // if the path doesn't match any of the urls you configured\n     *   // otherwise will take care of routing the user to the\n     *   // specified url\n     *   $urlRouterProvider.otherwise('/index');\n     *\n     *   // Example of using function rule as param\n     *   $urlRouterProvider.otherwise(function ($injector, $location) {\n     *     return '/a/valid/url';\n     *   });\n     * });\n     * ```\n     *\n     * @param rule\n     * The url path you want to redirect to or a function rule that returns the url path or performs a `$state.go()`.\n     * The function version is passed two params: `$injector` and `$location` services, and should return a url string.\n     *\n     * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n     */\n    UrlRouterProvider.prototype.otherwise = function (rule) {\n        var _this = this;\n        var urlRules = this.router.urlService.rules;\n        if (isString(rule)) {\n            urlRules.otherwise(rule);\n        }\n        else if (isFunction(rule)) {\n            urlRules.otherwise(function () { return rule(services.$injector, _this.router.locationService); });\n        }\n        else {\n            throw new Error(\"'rule' must be a string or function\");\n        }\n        return this;\n    };\n    /**\n     * Registers a handler for a given url matching.\n     *\n     * If the handler is a string, it is\n     * treated as a redirect, and is interpolated according to the syntax of match\n     * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n     *\n     * If the handler is a function, it is injectable.\n     * It gets invoked if `$location` matches.\n     * You have the option of inject the match object as `$match`.\n     *\n     * The handler can return\n     *\n     * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n     *   will continue trying to find another one that matches.\n     * - **string** which is treated as a redirect and passed to `$location.url()`\n     * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n     *\n     * #### Example:\n     * ```js\n     * var app = angular.module('app', ['ui.router.router']);\n     *\n     * app.config(function ($urlRouterProvider) {\n     *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n     *     if ($state.$current.navigable !== state ||\n     *         !equalForKeys($match, $stateParams) {\n     *      $state.transitionTo(state, $match, false);\n     *     }\n     *   });\n     * });\n     * ```\n     *\n     * @param what A pattern string to match, compiled as a [[UrlMatcher]].\n     * @param handler The path (or function that returns a path) that you want to redirect your user to.\n     * @param ruleCallback [optional] A callback that receives the `rule` registered with [[UrlMatcher.rule]]\n     *\n     * Note: the handler may also invoke arbitrary code, such as `$state.go()`\n     */\n    UrlRouterProvider.prototype.when = function (what, handler) {\n        if (isArray(handler) || isFunction(handler)) {\n            handler = UrlRouterProvider.injectableHandler(this.router, handler);\n        }\n        this.router.urlService.rules.when(what, handler);\n        return this;\n    };\n    /**\n     * Disables monitoring of the URL.\n     *\n     * Call this method before UI-Router has bootstrapped.\n     * It will stop UI-Router from performing the initial url sync.\n     *\n     * This can be useful to perform some asynchronous initialization before the router starts.\n     * Once the initialization is complete, call [[listen]] to tell UI-Router to start watching and synchronizing the URL.\n     *\n     * #### Example:\n     * ```js\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.config(function ($urlRouterProvider) {\n     *   // Prevent $urlRouter from automatically intercepting URL changes;\n     *   $urlRouterProvider.deferIntercept();\n     * })\n     *\n     * app.run(function (MyService, $urlRouter, $http) {\n     *   $http.get(\"/stuff\").then(function(resp) {\n     *     MyService.doStuff(resp.data);\n     *     $urlRouter.listen();\n     *     $urlRouter.sync();\n     *   });\n     * });\n     * ```\n     *\n     * @param defer Indicates whether to defer location change interception.\n     *        Passing no parameter is equivalent to `true`.\n     */\n    UrlRouterProvider.prototype.deferIntercept = function (defer) {\n        this.router.urlService.deferIntercept(defer);\n    };\n    return UrlRouterProvider;\n}());\nexport { UrlRouterProvider };\n//# sourceMappingURL=urlRouterProvider.js.map","/**\n * # Angular 1 types\n *\n * UI-Router core provides various Typescript types which you can use for code completion and validating parameter values, etc.\n * The customizations to the core types for Angular UI-Router are documented here.\n *\n * The optional [[$resolve]] service is also documented here.\n *\n * @preferred @publicapi @module ng1\n */ /** */\nimport { ng as angular } from './angular';\nimport { services, applyPairs, isString, trace, extend, UIRouter, unnestR, } from '@uirouter/core';\nimport { ng1ViewsBuilder, getNg1ViewConfigFactory } from './statebuilders/views';\nimport { TemplateFactory } from './templateFactory';\nimport { StateProvider } from './stateProvider';\nimport { getStateHookBuilder } from './statebuilders/onEnterExitRetain';\nimport { Ng1LocationServices } from './locationServices';\nimport { UrlRouterProvider } from './urlRouterProvider';\nangular.module('ui.router.angular1', []);\nvar mod_init = angular.module('ui.router.init', ['ng']);\nvar mod_util = angular.module('ui.router.util', ['ui.router.init']);\nvar mod_rtr = angular.module('ui.router.router', ['ui.router.util']);\nvar mod_state = angular.module('ui.router.state', ['ui.router.router', 'ui.router.util', 'ui.router.angular1']);\nvar mod_main = angular.module('ui.router', ['ui.router.init', 'ui.router.state', 'ui.router.angular1']);\nvar mod_cmpt = angular.module('ui.router.compat', ['ui.router']); // tslint:disable-line\nvar router = null;\n$uiRouterProvider.$inject = ['$locationProvider'];\n/** This angular 1 provider instantiates a Router and exposes its services via the angular injector */\nfunction $uiRouterProvider($locationProvider) {\n    // Create a new instance of the Router when the $uiRouterProvider is initialized\n    router = this.router = new UIRouter();\n    router.stateProvider = new StateProvider(router.stateRegistry, router.stateService);\n    // Apply ng1 specific StateBuilder code for `views`, `resolve`, and `onExit/Retain/Enter` properties\n    router.stateRegistry.decorator('views', ng1ViewsBuilder);\n    router.stateRegistry.decorator('onExit', getStateHookBuilder('onExit'));\n    router.stateRegistry.decorator('onRetain', getStateHookBuilder('onRetain'));\n    router.stateRegistry.decorator('onEnter', getStateHookBuilder('onEnter'));\n    router.viewService._pluginapi._viewConfigFactory('ng1', getNg1ViewConfigFactory());\n    var ng1LocationService = (router.locationService = router.locationConfig = new Ng1LocationServices($locationProvider));\n    Ng1LocationServices.monkeyPatchPathParameterType(router);\n    // backwards compat: also expose router instance as $uiRouterProvider.router\n    router['router'] = router;\n    router['$get'] = $get;\n    $get.$inject = ['$location', '$browser', '$window', '$sniffer', '$rootScope', '$http', '$templateCache'];\n    function $get($location, $browser, $window, $sniffer, $rootScope, $http, $templateCache) {\n        ng1LocationService._runtimeServices($rootScope, $location, $sniffer, $browser, $window);\n        delete router['router'];\n        delete router['$get'];\n        return router;\n    }\n    return router;\n}\nvar getProviderFor = function (serviceName) { return [\n    '$uiRouterProvider',\n    function ($urp) {\n        var service = $urp.router[serviceName];\n        service['$get'] = function () { return service; };\n        return service;\n    },\n]; };\n// This effectively calls $get() on `$uiRouterProvider` to trigger init (when ng enters runtime)\nrunBlock.$inject = ['$injector', '$q', '$uiRouter'];\nfunction runBlock($injector, $q, $uiRouter) {\n    services.$injector = $injector;\n    services.$q = $q;\n    // https://github.com/angular-ui/ui-router/issues/3678\n    if (!$injector.hasOwnProperty('strictDi')) {\n        try {\n            $injector.invoke(function (checkStrictDi) { });\n        }\n        catch (error) {\n            $injector.strictDi = !!/strict mode/.exec(error && error.toString());\n        }\n    }\n    // The $injector is now available.\n    // Find any resolvables that had dependency annotation deferred\n    $uiRouter.stateRegistry\n        .get()\n        .map(function (x) { return x.$$state().resolvables; })\n        .reduce(unnestR, [])\n        .filter(function (x) { return x.deps === 'deferred'; })\n        .forEach(function (resolvable) { return (resolvable.deps = $injector.annotate(resolvable.resolveFn, $injector.strictDi)); });\n}\n// $urlRouter service and $urlRouterProvider\nvar getUrlRouterProvider = function (uiRouter) { return (uiRouter.urlRouterProvider = new UrlRouterProvider(uiRouter)); };\n// $state service and $stateProvider\n// $urlRouter service and $urlRouterProvider\nvar getStateProvider = function () { return extend(router.stateProvider, { $get: function () { return router.stateService; } }); };\nwatchDigests.$inject = ['$rootScope'];\nexport function watchDigests($rootScope) {\n    $rootScope.$watch(function () {\n        trace.approximateDigests++;\n    });\n}\nmod_init.provider('$uiRouter', $uiRouterProvider);\nmod_rtr.provider('$urlRouter', ['$uiRouterProvider', getUrlRouterProvider]);\nmod_util.provider('$urlService', getProviderFor('urlService'));\nmod_util.provider('$urlMatcherFactory', ['$uiRouterProvider', function () { return router.urlMatcherFactory; }]);\nmod_util.provider('$templateFactory', function () { return new TemplateFactory(); });\nmod_state.provider('$stateRegistry', getProviderFor('stateRegistry'));\nmod_state.provider('$uiRouterGlobals', getProviderFor('globals'));\nmod_state.provider('$transitions', getProviderFor('transitionService'));\nmod_state.provider('$state', ['$uiRouterProvider', getStateProvider]);\nmod_state.factory('$stateParams', ['$uiRouter', function ($uiRouter) { return $uiRouter.globals.params; }]);\nmod_main.factory('$view', function () { return router.viewService; });\nmod_main.service('$trace', function () { return trace; });\nmod_main.run(watchDigests);\nmod_util.run(['$urlMatcherFactory', function ($urlMatcherFactory) { }]);\nmod_state.run(['$state', function ($state) { }]);\nmod_rtr.run(['$urlRouter', function ($urlRouter) { }]);\nmod_init.run(runBlock);\n/** @hidden TODO: find a place to move this */\nexport var getLocals = function (ctx) {\n    var tokens = ctx.getTokens().filter(isString);\n    var tuples = tokens.map(function (key) {\n        var resolvable = ctx.getResolvable(key);\n        var waitPolicy = ctx.getPolicy(resolvable).async;\n        return [key, waitPolicy === 'NOWAIT' ? resolvable.promise : resolvable.data];\n    });\n    return tuples.reduce(applyPairs, {});\n};\n//# sourceMappingURL=services.js.map","/**\n * # Angular 1 Directives\n *\n * These are the directives included in UI-Router for Angular 1.\n * These directives are used in templates to create viewports and link/navigate to states.\n *\n * @preferred @publicapi @module directives\n */ /** */\nimport { ng as angular } from '../angular';\nimport { extend, forEach, tail, isString, isObject, isArray, parse, noop, unnestR, identity, uniqR, inArray, removeFrom, } from '@uirouter/core';\n/** @hidden */\nfunction parseStateRef(ref) {\n    var parsed;\n    var paramsOnly = ref.match(/^\\s*({[^}]*})\\s*$/);\n    if (paramsOnly)\n        ref = '(' + paramsOnly[1] + ')';\n    parsed = ref.replace(/\\n/g, ' ').match(/^\\s*([^(]*?)\\s*(\\((.*)\\))?\\s*$/);\n    if (!parsed || parsed.length !== 4)\n        throw new Error(\"Invalid state ref '\" + ref + \"'\");\n    return { state: parsed[1] || null, paramExpr: parsed[3] || null };\n}\n/** @hidden */\nfunction stateContext(el) {\n    var $uiView = el.parent().inheritedData('$uiView');\n    var path = parse('$cfg.path')($uiView);\n    return path ? tail(path).state.name : undefined;\n}\n/** @hidden */\nfunction processedDef($state, $element, def) {\n    var uiState = def.uiState || $state.current.name;\n    var uiStateOpts = extend(defaultOpts($element, $state), def.uiStateOpts || {});\n    var href = $state.href(uiState, def.uiStateParams, uiStateOpts);\n    return { uiState: uiState, uiStateParams: def.uiStateParams, uiStateOpts: uiStateOpts, href: href };\n}\n/** @hidden */\nfunction getTypeInfo(el) {\n    // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n    var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';\n    var isForm = el[0].nodeName === 'FORM';\n    return {\n        attr: isForm ? 'action' : isSvg ? 'xlink:href' : 'href',\n        isAnchor: el.prop('tagName').toUpperCase() === 'A',\n        clickable: !isForm,\n    };\n}\n/** @hidden */\nfunction clickHook(el, $state, $timeout, type, getDef) {\n    return function (e) {\n        var button = e.which || e.button, target = getDef();\n        if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {\n            // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n            var transition_1 = $timeout(function () {\n                if (!el.attr('disabled')) {\n                    $state.go(target.uiState, target.uiStateParams, target.uiStateOpts);\n                }\n            });\n            e.preventDefault();\n            // if the state has no URL, ignore one preventDefault from the <a> directive.\n            var ignorePreventDefaultCount_1 = type.isAnchor && !target.href ? 1 : 0;\n            e.preventDefault = function () {\n                if (ignorePreventDefaultCount_1-- <= 0)\n                    $timeout.cancel(transition_1);\n            };\n        }\n    };\n}\n/** @hidden */\nfunction defaultOpts(el, $state) {\n    return {\n        relative: stateContext(el) || $state.$current,\n        inherit: true,\n        source: 'sref',\n    };\n}\n/** @hidden */\nfunction bindEvents(element, scope, hookFn, uiStateOpts) {\n    var events;\n    if (uiStateOpts) {\n        events = uiStateOpts.events;\n    }\n    if (!isArray(events)) {\n        events = ['click'];\n    }\n    var on = element.on ? 'on' : 'bind';\n    for (var _i = 0, events_1 = events; _i < events_1.length; _i++) {\n        var event_1 = events_1[_i];\n        element[on](event_1, hookFn);\n    }\n    scope.$on('$destroy', function () {\n        var off = element.off ? 'off' : 'unbind';\n        for (var _i = 0, events_2 = events; _i < events_2.length; _i++) {\n            var event_2 = events_2[_i];\n            element[off](event_2, hookFn);\n        }\n    });\n}\n/**\n * `ui-sref`: A directive for linking to a state\n *\n * A directive which links to a state (and optionally, parameters).\n * When clicked, this directive activates the linked state with the supplied parameter values.\n *\n * ### Linked State\n * The attribute value of the `ui-sref` is the name of the state to link to.\n *\n * #### Example:\n * This will activate the `home` state when the link is clicked.\n * ```html\n * <a ui-sref=\"home\">Home</a>\n * ```\n *\n * ### Relative Links\n * You can also use relative state paths within `ui-sref`, just like a relative path passed to `$state.go()` ([[StateService.go]]).\n * You just need to be aware that the path is relative to the state that *created* the link.\n * This allows a state to create a relative `ui-sref` which always targets the same destination.\n *\n * #### Example:\n * Both these links are relative to the parent state, even when a child state is currently active.\n * ```html\n * <a ui-sref=\".child1\">child 1 state</a>\n * <a ui-sref=\".child2\">child 2 state</a>\n * ```\n *\n * This link activates the parent state.\n * ```html\n * <a ui-sref=\"^\">Return</a>\n * ```\n *\n * ### hrefs\n * If the linked state has a URL, the directive will automatically generate and\n * update the `href` attribute (using the [[StateService.href]]  method).\n *\n * #### Example:\n * Assuming the `users` state has a url of `/users/`\n * ```html\n * <a ui-sref=\"users\" href=\"/users/\">Users</a>\n * ```\n *\n * ### Parameter Values\n * In addition to the state name, a `ui-sref` can include parameter values which are applied when activating the state.\n * Param values can be provided in the `ui-sref` value after the state name, enclosed by parentheses.\n * The content inside the parentheses is an expression, evaluated to the parameter values.\n *\n * #### Example:\n * This example renders a list of links to users.\n * The state's `userId` parameter value comes from each user's `user.id` property.\n * ```html\n * <li ng-repeat=\"user in users\">\n *   <a ui-sref=\"users.detail({ userId: user.id })\">{{ user.displayName }}</a>\n * </li>\n * ```\n *\n * Note:\n * The parameter values expression is `$watch`ed for updates.\n *\n * ### Transition Options\n * You can specify [[TransitionOptions]] to pass to [[StateService.go]] by using the `ui-sref-opts` attribute.\n * Options are restricted to `location`, `inherit`, and `reload`.\n *\n * #### Example:\n * ```html\n * <a ui-sref=\"home\" ui-sref-opts=\"{ reload: true }\">Home</a>\n * ```\n *\n * ### Other DOM Events\n *\n * You can also customize which DOM events to respond to (instead of `click`) by\n * providing an `events` array in the `ui-sref-opts` attribute.\n *\n * #### Example:\n * ```html\n * <input type=\"text\" ui-sref=\"contacts\" ui-sref-opts=\"{ events: ['change', 'blur'] }\">\n * ```\n *\n * ### Highlighting the active link\n * This directive can be used in conjunction with [[uiSrefActive]] to highlight the active link.\n *\n * ### Examples\n * If you have the following template:\n *\n * ```html\n * <a ui-sref=\"home\">Home</a>\n * <a ui-sref=\"about\">About</a>\n * <a ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n *     </li>\n * </ul>\n * ```\n *\n * Then (assuming the current state is `contacts`) the rendered html including hrefs would be:\n *\n * ```html\n * <a href=\"#/home\" ui-sref=\"home\">Home</a>\n * <a href=\"#/about\" ui-sref=\"about\">About</a>\n * <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n *     </li>\n * </ul>\n *\n * <a href=\"#/home\" ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n * ```\n *\n * ### Notes\n *\n * - You can use `ui-sref` to change **only the parameter values** by omitting the state name and parentheses.\n * #### Example:\n * Sets the `lang` parameter to `en` and remains on the same state.\n *\n * ```html\n * <a ui-sref=\"{ lang: 'en' }\">English</a>\n * ```\n *\n * - A middle-click, right-click, or ctrl-click is handled (natively) by the browser to open the href in a new window, for example.\n *\n * - Unlike the parameter values expression, the state name is not `$watch`ed (for performance reasons).\n * If you need to dynamically update the state being linked to, use the fully dynamic [[uiState]] directive.\n */\nvar uiSrefDirective;\nuiSrefDirective = [\n    '$uiRouter',\n    '$timeout',\n    function $StateRefDirective($uiRouter, $timeout) {\n        var $state = $uiRouter.stateService;\n        return {\n            restrict: 'A',\n            require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n            link: function (scope, element, attrs, uiSrefActive) {\n                var type = getTypeInfo(element);\n                var active = uiSrefActive[1] || uiSrefActive[0];\n                var unlinkInfoFn = null;\n                var hookFn;\n                var rawDef = {};\n                var getDef = function () { return processedDef($state, element, rawDef); };\n                var ref = parseStateRef(attrs.uiSref);\n                rawDef.uiState = ref.state;\n                rawDef.uiStateOpts = attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {};\n                function update() {\n                    var def = getDef();\n                    if (unlinkInfoFn)\n                        unlinkInfoFn();\n                    if (active)\n                        unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams);\n                    if (def.href != null)\n                        attrs.$set(type.attr, def.href);\n                }\n                if (ref.paramExpr) {\n                    scope.$watch(ref.paramExpr, function (val) {\n                        rawDef.uiStateParams = extend({}, val);\n                        update();\n                    }, true);\n                    rawDef.uiStateParams = extend({}, scope.$eval(ref.paramExpr));\n                }\n                update();\n                scope.$on('$destroy', $uiRouter.stateRegistry.onStatesChanged(update));\n                scope.$on('$destroy', $uiRouter.transitionService.onSuccess({}, update));\n                if (!type.clickable)\n                    return;\n                hookFn = clickHook(element, $state, $timeout, type, getDef);\n                bindEvents(element, scope, hookFn, rawDef.uiStateOpts);\n            },\n        };\n    },\n];\n/**\n * `ui-state`: A fully dynamic directive for linking to a state\n *\n * A directive which links to a state (and optionally, parameters).\n * When clicked, this directive activates the linked state with the supplied parameter values.\n *\n * **This directive is very similar to [[uiSref]], but it `$observe`s and `$watch`es/evaluates all its inputs.**\n *\n * A directive which links to a state (and optionally, parameters).\n * When clicked, this directive activates the linked state with the supplied parameter values.\n *\n * ### Linked State\n * The attribute value of `ui-state` is an expression which is `$watch`ed and evaluated as the state to link to.\n * **This is in contrast with `ui-sref`, which takes a state name as a string literal.**\n *\n * #### Example:\n * Create a list of links.\n * ```html\n * <li ng-repeat=\"link in navlinks\">\n *   <a ui-state=\"link.state\">{{ link.displayName }}</a>\n * </li>\n * ```\n *\n * ### Relative Links\n * If the expression evaluates to a relative path, it is processed like [[uiSref]].\n * You just need to be aware that the path is relative to the state that *created* the link.\n * This allows a state to create relative `ui-state` which always targets the same destination.\n *\n * ### hrefs\n * If the linked state has a URL, the directive will automatically generate and\n * update the `href` attribute (using the [[StateService.href]]  method).\n *\n * ### Parameter Values\n * In addition to the state name expression, a `ui-state` can include parameter values which are applied when activating the state.\n * Param values should be provided using the `ui-state-params` attribute.\n * The `ui-state-params` attribute value is `$watch`ed and evaluated as an expression.\n *\n * #### Example:\n * This example renders a list of links with param values.\n * The state's `userId` parameter value comes from each user's `user.id` property.\n * ```html\n * <li ng-repeat=\"link in navlinks\">\n *   <a ui-state=\"link.state\" ui-state-params=\"link.params\">{{ link.displayName }}</a>\n * </li>\n * ```\n *\n * ### Transition Options\n * You can specify [[TransitionOptions]] to pass to [[StateService.go]] by using the `ui-state-opts` attribute.\n * Options are restricted to `location`, `inherit`, and `reload`.\n * The value of the `ui-state-opts` is `$watch`ed and evaluated as an expression.\n *\n * #### Example:\n * ```html\n * <a ui-state=\"returnto.state\" ui-state-opts=\"{ reload: true }\">Home</a>\n * ```\n *\n * ### Other DOM Events\n *\n * You can also customize which DOM events to respond to (instead of `click`) by\n * providing an `events` array in the `ui-state-opts` attribute.\n *\n * #### Example:\n * ```html\n * <input type=\"text\" ui-state=\"contacts\" ui-state-opts=\"{ events: ['change', 'blur'] }\">\n * ```\n *\n * ### Highlighting the active link\n * This directive can be used in conjunction with [[uiSrefActive]] to highlight the active link.\n *\n * ### Notes\n *\n * - You can use `ui-params` to change **only the parameter values** by omitting the state name and supplying only `ui-state-params`.\n *   However, it might be simpler to use [[uiSref]] parameter-only links.\n *\n * #### Example:\n * Sets the `lang` parameter to `en` and remains on the same state.\n *\n * ```html\n * <a ui-state=\"\" ui-state-params=\"{ lang: 'en' }\">English</a>\n * ```\n *\n * - A middle-click, right-click, or ctrl-click is handled (natively) by the browser to open the href in a new window, for example.\n * ```\n */\nvar uiStateDirective;\nuiStateDirective = [\n    '$uiRouter',\n    '$timeout',\n    function $StateRefDynamicDirective($uiRouter, $timeout) {\n        var $state = $uiRouter.stateService;\n        return {\n            restrict: 'A',\n            require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n            link: function (scope, element, attrs, uiSrefActive) {\n                var type = getTypeInfo(element);\n                var active = uiSrefActive[1] || uiSrefActive[0];\n                var unlinkInfoFn = null;\n                var hookFn;\n                var rawDef = {};\n                var getDef = function () { return processedDef($state, element, rawDef); };\n                var inputAttrs = ['uiState', 'uiStateParams', 'uiStateOpts'];\n                var watchDeregFns = inputAttrs.reduce(function (acc, attr) { return ((acc[attr] = noop), acc); }, {});\n                function update() {\n                    var def = getDef();\n                    if (unlinkInfoFn)\n                        unlinkInfoFn();\n                    if (active)\n                        unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams);\n                    if (def.href != null)\n                        attrs.$set(type.attr, def.href);\n                }\n                inputAttrs.forEach(function (field) {\n                    rawDef[field] = attrs[field] ? scope.$eval(attrs[field]) : null;\n                    attrs.$observe(field, function (expr) {\n                        watchDeregFns[field]();\n                        watchDeregFns[field] = scope.$watch(expr, function (newval) {\n                            rawDef[field] = newval;\n                            update();\n                        }, true);\n                    });\n                });\n                update();\n                scope.$on('$destroy', $uiRouter.stateRegistry.onStatesChanged(update));\n                scope.$on('$destroy', $uiRouter.transitionService.onSuccess({}, update));\n                if (!type.clickable)\n                    return;\n                hookFn = clickHook(element, $state, $timeout, type, getDef);\n                bindEvents(element, scope, hookFn, rawDef.uiStateOpts);\n            },\n        };\n    },\n];\n/**\n * `ui-sref-active` and `ui-sref-active-eq`: A directive that adds a CSS class when a `ui-sref` is active\n *\n * A directive working alongside [[uiSref]] and [[uiState]] to add classes to an element when the\n * related directive's state is active (and remove them when it is inactive).\n *\n * The primary use-case is to highlight the active link in navigation menus,\n * distinguishing it from the inactive menu items.\n *\n * ### Linking to a `ui-sref` or `ui-state`\n * `ui-sref-active` can live on the same element as `ui-sref`/`ui-state`, or it can be on a parent element.\n * If a `ui-sref-active` is a parent to more than one `ui-sref`/`ui-state`, it will apply the CSS class when **any of the links are active**.\n *\n * ### Matching\n *\n * The `ui-sref-active` directive applies the CSS class when the `ui-sref`/`ui-state`'s target state **or any child state is active**.\n * This is a \"fuzzy match\" which uses [[StateService.includes]].\n *\n * The `ui-sref-active-eq` directive applies the CSS class when the `ui-sref`/`ui-state`'s target state is directly active (not when child states are active).\n * This is an \"exact match\" which uses [[StateService.is]].\n *\n * ### Parameter values\n * If the `ui-sref`/`ui-state` includes parameter values, the current parameter values must match the link's values for the link to be highlighted.\n * This allows a list of links to the same state with different parameters to be rendered, and the correct one highlighted.\n *\n * #### Example:\n * ```html\n * <li ng-repeat=\"user in users\" ui-sref-active=\"active\">\n *   <a ui-sref=\"user.details({ userId: user.id })\">{{ user.lastName }}</a>\n * </li>\n * ```\n *\n * ### Examples\n *\n * Given the following template:\n * #### Example:\n * ```html\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item\">\n *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * ```\n *\n * When the app state is `app.user` (or any child state),\n * and contains the state parameter \"user\" with value \"bilbobaggins\",\n * the resulting HTML will appear as (note the 'active' class):\n *\n * ```html\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item active\">\n *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * ```\n *\n * ### Glob mode\n *\n * It is possible to pass `ui-sref-active` an expression that evaluates to an object.\n * The objects keys represent active class names and values represent the respective state names/globs.\n * `ui-sref-active` will match if the current active state **includes** any of\n * the specified state names/globs, even the abstract ones.\n *\n * #### Example:\n * Given the following template, with \"admin\" being an abstract state:\n * ```html\n * <div ui-sref-active=\"{'active': 'admin.**'}\">\n *   <a ui-sref-active=\"active\" ui-sref=\"admin.roles\">Roles</a>\n * </div>\n * ```\n *\n * Arrays are also supported as values in the `ngClass`-like interface.\n * This allows multiple states to add `active` class.\n *\n * #### Example:\n * Given the following template, with \"admin.roles\" being the current state, the class will be added too:\n * ```html\n * <div ui-sref-active=\"{'active': ['owner.**', 'admin.**']}\">\n *   <a ui-sref-active=\"active\" ui-sref=\"admin.roles\">Roles</a>\n * </div>\n * ```\n *\n * When the current state is \"admin.roles\" the \"active\" class will be applied to both the `<div>` and `<a>` elements.\n * It is important to note that the state names/globs passed to `ui-sref-active` override any state provided by a linked `ui-sref`.\n *\n * ### Notes:\n *\n * - The class name is interpolated **once** during the directives link time (any further changes to the\n * interpolated value are ignored).\n *\n * - Multiple classes may be specified in a space-separated format: `ui-sref-active='class1 class2 class3'`\n */\nvar uiSrefActiveDirective;\nuiSrefActiveDirective = [\n    '$state',\n    '$stateParams',\n    '$interpolate',\n    '$uiRouter',\n    function $StateRefActiveDirective($state, $stateParams, $interpolate, $uiRouter) {\n        return {\n            restrict: 'A',\n            controller: [\n                '$scope',\n                '$element',\n                '$attrs',\n                function ($scope, $element, $attrs) {\n                    var states = [];\n                    var activeEqClass;\n                    var uiSrefActive;\n                    // There probably isn't much point in $observing this\n                    // uiSrefActive and uiSrefActiveEq share the same directive object with some\n                    // slight difference in logic routing\n                    activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);\n                    try {\n                        uiSrefActive = $scope.$eval($attrs.uiSrefActive);\n                    }\n                    catch (e) {\n                        // Do nothing. uiSrefActive is not a valid expression.\n                        // Fall back to using $interpolate below\n                    }\n                    uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);\n                    setStatesFromDefinitionObject(uiSrefActive);\n                    // Allow uiSref to communicate with uiSrefActive[Equals]\n                    this.$$addStateInfo = function (newState, newParams) {\n                        // we already got an explicit state provided by ui-sref-active, so we\n                        // shadow the one that comes from ui-sref\n                        if (isObject(uiSrefActive) && states.length > 0) {\n                            return;\n                        }\n                        var deregister = addState(newState, newParams, uiSrefActive);\n                        update();\n                        return deregister;\n                    };\n                    function updateAfterTransition(trans) {\n                        trans.promise.then(update, noop);\n                    }\n                    $scope.$on('$destroy', setupEventListeners());\n                    if ($uiRouter.globals.transition) {\n                        updateAfterTransition($uiRouter.globals.transition);\n                    }\n                    function setupEventListeners() {\n                        var deregisterStatesChangedListener = $uiRouter.stateRegistry.onStatesChanged(handleStatesChanged);\n                        var deregisterOnStartListener = $uiRouter.transitionService.onStart({}, updateAfterTransition);\n                        var deregisterStateChangeSuccessListener = $scope.$on('$stateChangeSuccess', update);\n                        return function cleanUp() {\n                            deregisterStatesChangedListener();\n                            deregisterOnStartListener();\n                            deregisterStateChangeSuccessListener();\n                        };\n                    }\n                    function handleStatesChanged() {\n                        setStatesFromDefinitionObject(uiSrefActive);\n                    }\n                    function setStatesFromDefinitionObject(statesDefinition) {\n                        if (isObject(statesDefinition)) {\n                            states = [];\n                            forEach(statesDefinition, function (stateOrName, activeClass) {\n                                // Helper function to abstract adding state.\n                                var addStateForClass = function (stateOrName, activeClass) {\n                                    var ref = parseStateRef(stateOrName);\n                                    addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);\n                                };\n                                if (isString(stateOrName)) {\n                                    // If state is string, just add it.\n                                    addStateForClass(stateOrName, activeClass);\n                                }\n                                else if (isArray(stateOrName)) {\n                                    // If state is an array, iterate over it and add each array item individually.\n                                    forEach(stateOrName, function (stateOrName) {\n                                        addStateForClass(stateOrName, activeClass);\n                                    });\n                                }\n                            });\n                        }\n                    }\n                    function addState(stateName, stateParams, activeClass) {\n                        var state = $state.get(stateName, stateContext($element));\n                        var stateInfo = {\n                            state: state || { name: stateName },\n                            params: stateParams,\n                            activeClass: activeClass,\n                        };\n                        states.push(stateInfo);\n                        return function removeState() {\n                            removeFrom(states)(stateInfo);\n                        };\n                    }\n                    // Update route state\n                    function update() {\n                        var splitClasses = function (str) { return str.split(/\\s/).filter(identity); };\n                        var getClasses = function (stateList) {\n                            return stateList\n                                .map(function (x) { return x.activeClass; })\n                                .map(splitClasses)\n                                .reduce(unnestR, []);\n                        };\n                        var allClasses = getClasses(states)\n                            .concat(splitClasses(activeEqClass))\n                            .reduce(uniqR, []);\n                        var fuzzyClasses = getClasses(states.filter(function (x) { return $state.includes(x.state.name, x.params); }));\n                        var exactlyMatchesAny = !!states.filter(function (x) { return $state.is(x.state.name, x.params); }).length;\n                        var exactClasses = exactlyMatchesAny ? splitClasses(activeEqClass) : [];\n                        var addClasses = fuzzyClasses.concat(exactClasses).reduce(uniqR, []);\n                        var removeClasses = allClasses.filter(function (cls) { return !inArray(addClasses, cls); });\n                        $scope.$evalAsync(function () {\n                            addClasses.forEach(function (className) { return $element.addClass(className); });\n                            removeClasses.forEach(function (className) { return $element.removeClass(className); });\n                        });\n                    }\n                    update();\n                },\n            ],\n        };\n    },\n];\nangular\n    .module('ui.router.state')\n    .directive('uiSref', uiSrefDirective)\n    .directive('uiSrefActive', uiSrefActiveDirective)\n    .directive('uiSrefActiveEq', uiSrefActiveDirective)\n    .directive('uiState', uiStateDirective);\n//# sourceMappingURL=stateDirectives.js.map","/** @publicapi @module directives */ /** */\nimport { extend, filter, isDefined, isFunction, isString, kebobString, noop, parse, ResolveContext, tail, trace, unnestR, } from '@uirouter/core';\nimport { ng as angular } from '../angular';\nimport { getLocals } from '../services';\nimport { Ng1ViewConfig } from '../statebuilders/views';\n/**\n * `ui-view`: A viewport directive which is filled in by a view from the active state.\n *\n * ### Attributes\n *\n * - `name`: (Optional) A view name.\n *   The name should be unique amongst the other views in the same state.\n *   You can have views of the same name that live in different states.\n *   The ui-view can be targeted in a View using the name ([[Ng1StateDeclaration.views]]).\n *\n * - `autoscroll`: an expression. When it evaluates to true, the `ui-view` will be scrolled into view when it is activated.\n *   Uses [[$uiViewScroll]] to do the scrolling.\n *\n * - `onload`: Expression to evaluate whenever the view updates.\n *\n * #### Example:\n * A view can be unnamed or named.\n * ```html\n * <!-- Unnamed -->\n * <div ui-view></div>\n *\n * <!-- Named -->\n * <div ui-view=\"viewName\"></div>\n *\n * <!-- Named (different style) -->\n * <ui-view name=\"viewName\"></ui-view>\n * ```\n *\n * You can only have one unnamed view within any template (or root html). If you are only using a\n * single view and it is unnamed then you can populate it like so:\n *\n * ```html\n * <div ui-view></div>\n * $stateProvider.state(\"home\", {\n *   template: \"<h1>HELLO!</h1>\"\n * })\n * ```\n *\n * The above is a convenient shortcut equivalent to specifying your view explicitly with the\n * [[Ng1StateDeclaration.views]] config property, by name, in this case an empty name:\n *\n * ```js\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }\n * })\n * ```\n *\n * But typically you'll only use the views property if you name your view or have more than one view\n * in the same template. There's not really a compelling reason to name a view if its the only one,\n * but you could if you wanted, like so:\n *\n * ```html\n * <div ui-view=\"main\"></div>\n * ```\n *\n * ```js\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"main\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }\n * })\n * ```\n *\n * Really though, you'll use views to set up multiple views:\n *\n * ```html\n * <div ui-view></div>\n * <div ui-view=\"chart\"></div>\n * <div ui-view=\"data\"></div>\n * ```\n *\n * ```js\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     },\n *     \"chart\": {\n *       template: \"<chart_thing/>\"\n *     },\n *     \"data\": {\n *       template: \"<data_thing/>\"\n *     }\n *   }\n * })\n * ```\n *\n * #### Examples for `autoscroll`:\n * ```html\n * <!-- If autoscroll present with no expression,\n *      then scroll ui-view into view -->\n * <ui-view autoscroll/>\n *\n * <!-- If autoscroll present with valid expression,\n *      then scroll ui-view into view if expression evaluates to true -->\n * <ui-view autoscroll='true'/>\n * <ui-view autoscroll='false'/>\n * <ui-view autoscroll='scopeVariable'/>\n * ```\n *\n * Resolve data:\n *\n * The resolved data from the state's `resolve` block is placed on the scope as `$resolve` (this\n * can be customized using [[Ng1ViewDeclaration.resolveAs]]).  This can be then accessed from the template.\n *\n * Note that when `controllerAs` is being used, `$resolve` is set on the controller instance *after* the\n * controller is instantiated.  The `$onInit()` hook can be used to perform initialization code which\n * depends on `$resolve` data.\n *\n * #### Example:\n * ```js\n * $stateProvider.state('home', {\n *   template: '<my-component user=\"$resolve.user\"></my-component>',\n *   resolve: {\n *     user: function(UserService) { return UserService.fetchUser(); }\n *   }\n * });\n * ```\n */\nexport var uiView;\nuiView = [\n    '$view',\n    '$animate',\n    '$uiViewScroll',\n    '$interpolate',\n    '$q',\n    function $ViewDirective($view, $animate, $uiViewScroll, $interpolate, $q) {\n        function getRenderer(attrs, scope) {\n            return {\n                enter: function (element, target, cb) {\n                    if (angular.version.minor > 2) {\n                        $animate.enter(element, null, target).then(cb);\n                    }\n                    else {\n                        $animate.enter(element, null, target, cb);\n                    }\n                },\n                leave: function (element, cb) {\n                    if (angular.version.minor > 2) {\n                        $animate.leave(element).then(cb);\n                    }\n                    else {\n                        $animate.leave(element, cb);\n                    }\n                },\n            };\n        }\n        function configsEqual(config1, config2) {\n            return config1 === config2;\n        }\n        var rootData = {\n            $cfg: { viewDecl: { $context: $view._pluginapi._rootViewContext() } },\n            $uiView: {},\n        };\n        var directive = {\n            count: 0,\n            restrict: 'ECA',\n            terminal: true,\n            priority: 400,\n            transclude: 'element',\n            compile: function (tElement, tAttrs, $transclude) {\n                return function (scope, $element, attrs) {\n                    var onloadExp = attrs['onload'] || '', autoScrollExp = attrs['autoscroll'], renderer = getRenderer(attrs, scope), inherited = $element.inheritedData('$uiView') || rootData, name = $interpolate(attrs['uiView'] || attrs['name'] || '')(scope) || '$default';\n                    var previousEl, currentEl, currentScope, viewConfig, unregister;\n                    var activeUIView = {\n                        $type: 'ng1',\n                        id: directive.count++,\n                        name: name,\n                        fqn: inherited.$uiView.fqn ? inherited.$uiView.fqn + '.' + name : name,\n                        config: null,\n                        configUpdated: configUpdatedCallback,\n                        get creationContext() {\n                            // The context in which this ui-view \"tag\" was created\n                            var fromParentTagConfig = parse('$cfg.viewDecl.$context')(inherited);\n                            // Allow <ui-view name=\"foo\"><ui-view name=\"bar\"></ui-view></ui-view>\n                            // See https://github.com/angular-ui/ui-router/issues/3355\n                            var fromParentTag = parse('$uiView.creationContext')(inherited);\n                            return fromParentTagConfig || fromParentTag;\n                        },\n                    };\n                    trace.traceUIViewEvent('Linking', activeUIView);\n                    function configUpdatedCallback(config) {\n                        if (config && !(config instanceof Ng1ViewConfig))\n                            return;\n                        if (configsEqual(viewConfig, config))\n                            return;\n                        trace.traceUIViewConfigUpdated(activeUIView, config && config.viewDecl && config.viewDecl.$context);\n                        viewConfig = config;\n                        updateView(config);\n                    }\n                    $element.data('$uiView', { $uiView: activeUIView });\n                    updateView();\n                    unregister = $view.registerUIView(activeUIView);\n                    scope.$on('$destroy', function () {\n                        trace.traceUIViewEvent('Destroying/Unregistering', activeUIView);\n                        unregister();\n                    });\n                    function cleanupLastView() {\n                        if (previousEl) {\n                            trace.traceUIViewEvent('Removing (previous) el', previousEl.data('$uiView'));\n                            previousEl.remove();\n                            previousEl = null;\n                        }\n                        if (currentScope) {\n                            trace.traceUIViewEvent('Destroying scope', activeUIView);\n                            currentScope.$destroy();\n                            currentScope = null;\n                        }\n                        if (currentEl) {\n                            var _viewData_1 = currentEl.data('$uiViewAnim');\n                            trace.traceUIViewEvent('Animate out', _viewData_1);\n                            renderer.leave(currentEl, function () {\n                                _viewData_1.$$animLeave.resolve();\n                                previousEl = null;\n                            });\n                            previousEl = currentEl;\n                            currentEl = null;\n                        }\n                    }\n                    function updateView(config) {\n                        var newScope = scope.$new();\n                        var animEnter = $q.defer(), animLeave = $q.defer();\n                        var $uiViewData = {\n                            $cfg: config,\n                            $uiView: activeUIView,\n                        };\n                        var $uiViewAnim = {\n                            $animEnter: animEnter.promise,\n                            $animLeave: animLeave.promise,\n                            $$animLeave: animLeave,\n                        };\n                        /**\n                         * @ngdoc event\n                         * @name ui.router.state.directive:ui-view#$viewContentLoading\n                         * @eventOf ui.router.state.directive:ui-view\n                         * @eventType emits on ui-view directive scope\n                         * @description\n                         *\n                         * Fired once the view **begins loading**, *before* the DOM is rendered.\n                         *\n                         * @param {Object} event Event object.\n                         * @param {string} viewName Name of the view.\n                         */\n                        newScope.$emit('$viewContentLoading', name);\n                        var cloned = $transclude(newScope, function (clone) {\n                            clone.data('$uiViewAnim', $uiViewAnim);\n                            clone.data('$uiView', $uiViewData);\n                            renderer.enter(clone, $element, function onUIViewEnter() {\n                                animEnter.resolve();\n                                if (currentScope)\n                                    currentScope.$emit('$viewContentAnimationEnded');\n                                if ((isDefined(autoScrollExp) && !autoScrollExp) || scope.$eval(autoScrollExp)) {\n                                    $uiViewScroll(clone);\n                                }\n                            });\n                            cleanupLastView();\n                        });\n                        currentEl = cloned;\n                        currentScope = newScope;\n                        /**\n                         * @ngdoc event\n                         * @name ui.router.state.directive:ui-view#$viewContentLoaded\n                         * @eventOf ui.router.state.directive:ui-view\n                         * @eventType emits on ui-view directive scope\n                         * @description           *\n                         * Fired once the view is **loaded**, *after* the DOM is rendered.\n                         *\n                         * @param {Object} event Event object.\n                         */\n                        currentScope.$emit('$viewContentLoaded', config || viewConfig);\n                        currentScope.$eval(onloadExp);\n                    }\n                };\n            },\n        };\n        return directive;\n    },\n];\n$ViewDirectiveFill.$inject = ['$compile', '$controller', '$transitions', '$view', '$q', '$timeout'];\n/** @hidden */\nfunction $ViewDirectiveFill($compile, $controller, $transitions, $view, $q, $timeout) {\n    var getControllerAs = parse('viewDecl.controllerAs');\n    var getResolveAs = parse('viewDecl.resolveAs');\n    return {\n        restrict: 'ECA',\n        priority: -400,\n        compile: function (tElement) {\n            var initial = tElement.html();\n            tElement.empty();\n            return function (scope, $element) {\n                var data = $element.data('$uiView');\n                if (!data) {\n                    $element.html(initial);\n                    $compile($element.contents())(scope);\n                    return;\n                }\n                var cfg = data.$cfg || { viewDecl: {}, getTemplate: noop };\n                var resolveCtx = cfg.path && new ResolveContext(cfg.path);\n                $element.html(cfg.getTemplate($element, resolveCtx) || initial);\n                trace.traceUIViewFill(data.$uiView, $element.html());\n                var link = $compile($element.contents());\n                var controller = cfg.controller;\n                var controllerAs = getControllerAs(cfg);\n                var resolveAs = getResolveAs(cfg);\n                var locals = resolveCtx && getLocals(resolveCtx);\n                scope[resolveAs] = locals;\n                if (controller) {\n                    var controllerInstance = ($controller(controller, extend({}, locals, { $scope: scope, $element: $element })));\n                    if (controllerAs) {\n                        scope[controllerAs] = controllerInstance;\n                        scope[controllerAs][resolveAs] = locals;\n                    }\n                    // TODO: Use $view service as a central point for registering component-level hooks\n                    // Then, when a component is created, tell the $view service, so it can invoke hooks\n                    // $view.componentLoaded(controllerInstance, { $scope: scope, $element: $element });\n                    // scope.$on('$destroy', () => $view.componentUnloaded(controllerInstance, { $scope: scope, $element: $element }));\n                    $element.data('$ngControllerController', controllerInstance);\n                    $element.children().data('$ngControllerController', controllerInstance);\n                    registerControllerCallbacks($q, $transitions, controllerInstance, scope, cfg);\n                }\n                // Wait for the component to appear in the DOM\n                if (isString(cfg.component)) {\n                    var kebobName = kebobString(cfg.component);\n                    var tagRegexp_1 = new RegExp(\"^(x-|data-)?\" + kebobName + \"$\", 'i');\n                    var getComponentController = function () {\n                        var directiveEl = [].slice\n                            .call($element[0].children)\n                            .filter(function (el) { return el && el.tagName && tagRegexp_1.exec(el.tagName); });\n                        return directiveEl && angular.element(directiveEl).data(\"$\" + cfg.component + \"Controller\");\n                    };\n                    var deregisterWatch_1 = scope.$watch(getComponentController, function (ctrlInstance) {\n                        if (!ctrlInstance)\n                            return;\n                        registerControllerCallbacks($q, $transitions, ctrlInstance, scope, cfg);\n                        deregisterWatch_1();\n                    });\n                }\n                link(scope);\n            };\n        },\n    };\n}\n/** @hidden */\nvar hasComponentImpl = typeof angular.module('ui.router')['component'] === 'function';\n/** @hidden incrementing id */\nvar _uiCanExitId = 0;\n/** @hidden TODO: move these callbacks to $view and/or `/hooks/components.ts` or something */\nfunction registerControllerCallbacks($q, $transitions, controllerInstance, $scope, cfg) {\n    // Call $onInit() ASAP\n    if (isFunction(controllerInstance.$onInit) && !((cfg.viewDecl.component || cfg.viewDecl.componentProvider) && hasComponentImpl)) {\n        controllerInstance.$onInit();\n    }\n    var viewState = tail(cfg.path).state.self;\n    var hookOptions = { bind: controllerInstance };\n    // Add component-level hook for onUiParamsChanged\n    if (isFunction(controllerInstance.uiOnParamsChanged)) {\n        var resolveContext = new ResolveContext(cfg.path);\n        var viewCreationTrans_1 = resolveContext.getResolvable('$transition$').data;\n        // Fire callback on any successful transition\n        var paramsUpdated = function ($transition$) {\n            // Exit early if the $transition$ is the same as the view was created within.\n            // Exit early if the $transition$ will exit the state the view is for.\n            if ($transition$ === viewCreationTrans_1 || $transition$.exiting().indexOf(viewState) !== -1)\n                return;\n            var toParams = $transition$.params('to');\n            var fromParams = $transition$.params('from');\n            var getNodeSchema = function (node) { return node.paramSchema; };\n            var toSchema = $transition$\n                .treeChanges('to')\n                .map(getNodeSchema)\n                .reduce(unnestR, []);\n            var fromSchema = $transition$\n                .treeChanges('from')\n                .map(getNodeSchema)\n                .reduce(unnestR, []);\n            // Find the to params that have different values than the from params\n            var changedToParams = toSchema.filter(function (param) {\n                var idx = fromSchema.indexOf(param);\n                return idx === -1 || !fromSchema[idx].type.equals(toParams[param.id], fromParams[param.id]);\n            });\n            // Only trigger callback if a to param has changed or is new\n            if (changedToParams.length) {\n                var changedKeys_1 = changedToParams.map(function (x) { return x.id; });\n                // Filter the params to only changed/new to params.  `$transition$.params()` may be used to get all params.\n                var newValues = filter(toParams, function (val, key) { return changedKeys_1.indexOf(key) !== -1; });\n                controllerInstance.uiOnParamsChanged(newValues, $transition$);\n            }\n        };\n        $scope.$on('$destroy', $transitions.onSuccess({}, paramsUpdated, hookOptions));\n    }\n    // Add component-level hook for uiCanExit\n    if (isFunction(controllerInstance.uiCanExit)) {\n        var id_1 = _uiCanExitId++;\n        var cacheProp_1 = '_uiCanExitIds';\n        // Returns true if a redirect transition already answered truthy\n        var prevTruthyAnswer_1 = function (trans) {\n            return !!trans && ((trans[cacheProp_1] && trans[cacheProp_1][id_1] === true) || prevTruthyAnswer_1(trans.redirectedFrom()));\n        };\n        // If a user answered yes, but the transition was later redirected, don't also ask for the new redirect transition\n        var wrappedHook = function (trans) {\n            var promise;\n            var ids = (trans[cacheProp_1] = trans[cacheProp_1] || {});\n            if (!prevTruthyAnswer_1(trans)) {\n                promise = $q.when(controllerInstance.uiCanExit(trans));\n                promise.then(function (val) { return (ids[id_1] = val !== false); });\n            }\n            return promise;\n        };\n        var criteria = { exiting: viewState.name };\n        $scope.$on('$destroy', $transitions.onBefore(criteria, wrappedHook, hookOptions));\n    }\n}\nangular.module('ui.router.state').directive('uiView', uiView);\nangular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n//# sourceMappingURL=viewDirective.js.map","/** @publicapi @module ng1 */ /** */\nimport { ng as angular } from './angular';\n/**\n * `isState` Filter: truthy if the current state is the parameter\n *\n * Translates to [[StateService.is]] `$state.is(\"stateName\")`.\n *\n * #### Example:\n * ```html\n * <div ng-if=\"'stateName' | isState\">show if state is 'stateName'</div>\n * ```\n */\n$IsStateFilter.$inject = ['$state'];\nfunction $IsStateFilter($state) {\n    var isFilter = function (state, params, options) {\n        return $state.is(state, params, options);\n    };\n    isFilter.$stateful = true;\n    return isFilter;\n}\n/**\n * `includedByState` Filter: truthy if the current state includes the parameter\n *\n * Translates to [[StateService.includes]]` $state.is(\"fullOrPartialStateName\")`.\n *\n * #### Example:\n * ```html\n * <div ng-if=\"'fullOrPartialStateName' | includedByState\">show if state includes 'fullOrPartialStateName'</div>\n * ```\n */\n$IncludedByStateFilter.$inject = ['$state'];\nfunction $IncludedByStateFilter($state) {\n    var includesFilter = function (state, params, options) {\n        return $state.includes(state, params, options);\n    };\n    includesFilter.$stateful = true;\n    return includesFilter;\n}\nangular\n    .module('ui.router.state')\n    .filter('isState', $IsStateFilter)\n    .filter('includedByState', $IncludedByStateFilter);\nexport { $IsStateFilter, $IncludedByStateFilter };\n//# sourceMappingURL=stateFilters.js.map","/** @publicapi @module ng1 */ /** */\nimport { ng as angular } from './angular';\n/** @hidden */\nfunction $ViewScrollProvider() {\n    var useAnchorScroll = false;\n    this.useAnchorScroll = function () {\n        useAnchorScroll = true;\n    };\n    this.$get = [\n        '$anchorScroll',\n        '$timeout',\n        function ($anchorScroll, $timeout) {\n            if (useAnchorScroll) {\n                return $anchorScroll;\n            }\n            return function ($element) {\n                return $timeout(function () {\n                    $element[0].scrollIntoView();\n                }, 0, false);\n            };\n        },\n    ];\n}\nangular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n//# sourceMappingURL=viewScroll.js.map","export * from './services';\nexport * from './statebuilders/views';\nexport * from './stateProvider';\nexport * from './urlRouterProvider';\nimport './injectables';\nimport './directives/stateDirectives';\nimport './stateFilters';\nimport './directives/viewDirective';\nimport './viewScroll';\nexport default 'ui.router';\nimport * as core from '@uirouter/core';\nexport { core };\nexport * from '@uirouter/core';\n//# sourceMappingURL=index.js.map"],"names":["ng","angular","getNg1ViewConfigFactory","templateFactory","path","view","services","$injector","get","Ng1ViewConfig","hasAnyKey","keys","obj","reduce","acc","key","isDefined","ng1ViewsBuilder","state","parent","compKeys","nonCompKeys","concat","allViewKeys","views","Error","name","filter","join","viewsObject","$default","pick","forEach","config","isString","component","extend","resolveAs","$type","$context","$name","normalized","ViewService","normalizeUIViewTarget","$uiViewName","uiViewName","$uiViewContextAnchor","uiViewContextAnchor","id","viewDecl","factory","_this","this","$id","loaded","getTemplate","uiView","context","makeComponentTemplate","bindings","template","prototype","load","$q","ResolveContext","params","node","paramValues","promises","when","fromConfig","controller","getController","all","then","results","trace","traceViewServiceEvent","provider","controllerProvider","isInjectable","deps","annotate","providerFn","isArray","tail","Resolvable","TemplateFactory","_useHttp","version","minor","$get","$http","$templateCache","$templateRequest","has","useHttpService","value","asTemplate","result","str","asComponent","fromString","templateUrl","fromUrl","templateProvider","fromProvider","componentProvider","fromComponentProvider","isFunction","url","cache","headers","Accept","response","data","prefix","kebob","camelCase","kebobed","kebobString","exec","attrs","cmpDefs","length","map","getBindings","unnestR","getComponentBindings","input","type","attrName","attr","resolveName","res","getResolvable","fn","args","kebobName","def","isObject","bindToController","scopeBindings","scope","bindingsObj","Object","tuple","StateProvider","stateRegistry","stateService","createProxyFunctions","val","decorator","func","definition","register","onInvalid","callback","getStateHookBuilder","hookName","stateObject","parentFn","hook","pathname","trans","subContext","treeChanges","$$state","locals","getLocals","$state$","$transition$","invoke","undefined","Ng1LocationServices","$locationProvider","_urlListeners","_lp","monkeyPatchPathParameterType","router","pathType","urlMatcherFactory","encode","x","toString","replace","m","~","/","decode","~~","~2F","dispose","onChange","push","removeFrom","html5Mode","enabled","$sniffer","history","baseHref","_baseHref","$browser","$window","location","newUrl","$location","_runtimeServices","$rootScope","$on","evt","_loc","UrlRouterProvider","injectableHandler","handler","match","$match","$stateParams","globals","urlService","urlRouter","update","interceptDeferred","listen","rule","ruleFn","BaseUrlRule","locationService","identity","rules","otherwise","urlRules","what","deferIntercept","defer","module","mod_init","mod_util","mod_rtr","mod_state","mod_main","$uiRouterProvider","UIRouter","stateProvider","viewService","_pluginapi","_viewConfigFactory","ng1LocationService","locationConfig","$inject","getProviderFor","serviceName","$urp","service","runBlock","$uiRouter","hasOwnProperty","checkStrictDi","error","strictDi","resolvables","resolvable","resolveFn","watchDigests","$watch","approximateDigests","uiRouter","urlRouterProvider","run","$urlMatcherFactory","$state","$urlRouter","uiSrefDirective","uiStateDirective","uiSrefActiveDirective","ctx","getTokens","getPolicy","async","promise","applyPairs","parseStateRef","ref","parsed","paramsOnly","paramExpr","stateContext","el","$uiView","inheritedData","parse","processedDef","$element","uiState","current","uiStateOpts","relative","$current","inherit","source","defaultOpts","href","uiStateParams","getTypeInfo","isSvg","call","prop","isForm","nodeName","isAnchor","toUpperCase","clickable","clickHook","$timeout","getDef","e","button","which","target","ctrlKey","metaKey","shiftKey","transition_1","go","preventDefault","ignorePreventDefaultCount_1","cancel","bindEvents","element","hookFn","events","on","_i","events_1","event_1","off","events_2","event_2","$IsStateFilter","isFilter","options","is","$stateful","$IncludedByStateFilter","includesFilter","includes","$ViewDirectiveFill","$compile","$controller","$transitions","$view","getControllerAs","getResolveAs","restrict","priority","compile","tElement","initial","html","empty","contents","cfg","$cfg","noop","resolveCtx","traceUIViewFill","link","controllerAs","controllerInstance","$scope","children","registerControllerCallbacks","tagRegexp_1","RegExp","deregisterWatch_1","directiveEl","slice","tagName","ctrlInstance","require","uiSrefActive","active","unlinkInfoFn","rawDef","uiSref","$$addStateInfo","$set","uiSrefOpts","$eval","onStatesChanged","transitionService","onSuccess","inputAttrs","watchDeregFns","field","$observe","expr","newval","$interpolate","$attrs","activeEqClass","deregisterStatesChangedListener","deregisterOnStartListener","deregisterStateChangeSuccessListener","states","uiSrefActiveEq","updateAfterTransition","handleStatesChanged","setStatesFromDefinitionObject","statesDefinition","stateOrName","activeClass","addStateForClass","addState","stateName","stateParams","stateInfo","splitClasses","split","getClasses","stateList","allClasses","uniqR","fuzzyClasses","exactClasses","addClasses","removeClasses","cls","inArray","$evalAsync","className","addClass","removeClass","newState","newParams","deregister","onStart","transition","directive","$animate","$uiViewScroll","rootData","_rootViewContext","count","terminal","transclude","tAttrs","$transclude","previousEl","currentEl","currentScope","viewConfig","unregister","onloadExp","autoScrollExp","renderer","enter","cb","leave","inherited","activeUIView","fqn","configUpdated","config1","config2","traceUIViewConfigUpdated","updateView","creationContext","fromParentTagConfig","fromParentTag","newScope","$new","animEnter","animLeave","$uiViewData","$uiViewAnim","$animEnter","$animLeave","$$animLeave","$emit","cloned","clone","resolve","traceUIViewEvent","remove","$destroy","_viewData_1","cleanupLastView","registerUIView","hasComponentImpl","_uiCanExitId","$onInit","viewState","self","hookOptions","bind","uiOnParamsChanged","viewCreationTrans_1","exiting","indexOf","toParams","fromParams","getNodeSchema","paramSchema","toSchema","fromSchema","changedToParams","param","idx","equals","changedKeys_1","newValues","uiCanExit","id_1","prevTruthyAnswer_1","redirectedFrom","criteria","onBefore","ids","useAnchorScroll","$anchorScroll","scrollIntoView"],"mappings":"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"}